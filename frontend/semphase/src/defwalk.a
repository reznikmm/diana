with PRINTNOD, TEXT2_IO; use PRINTNOD, TEXT2_IO; -- $$$$ debug only
with DIANA, DIANATTR, DIANAMAN; use DIANA, DIANAMAN, DIANATTR;
with DEFUTIL; use DEFUTIL;
with VISUTIL; use VISUTIL;
with UARITH;
with MAKENOD; use MAKENOD;
with NODWALK; use NODWALK;
with EXPTYPE, EXPRESO; use EXPTYPE, EXPRESO;
with REQUTIL; use REQUTIL;
with SETUTIL; use SETUTIL;
with DERIVED;
with gensubs; use gensubs;

package body DEFWALK is

    function COPY_COMP_LIST_IDS(COMP_LIST: TREE; H: H_TYPE) return TREE;
    function COPY_ITEM_S_IDS(ITEM_S: TREE; H: H_TYPE) return TREE;
    procedure WALK_COMP_LIST (COMP_LIST: TREE; H: H_TYPE);


    procedure PRINT_REAL(R: TREE) is -- $$$$ debug only
    begin
        if KIND(R) = DN_REAL_VAL then
            PRINT_TREE(D(XD_NUMER,R));
            PUT("/");
            PRINT_TREE(D(XD_DENOM,R));
        else
            PRINT_TREE(R);
        end if;
    end PRINT_REAL;


    -- $$$$ shouldn't be here
    function GET_SUBSTRUCT(TYPE_SPEC: TREE) return TREE is
        SUBTYPE_SPEC: TREE;
    begin
        if KIND(TYPE_SPEC) in CLASS_PRIVATE_SPEC then
            SUBTYPE_SPEC := D(SM_TYPE_SPEC, TYPE_SPEC);
            if SUBTYPE_SPEC /= CONST_VOID then
                return SUBTYPE_SPEC;
            end if;
        elsif KIND(TYPE_SPEC) = DN_INCOMPLETE then
            SUBTYPE_SPEC := D(XD_FULL_TYPE_SPEC, TYPE_SPEC);
            if SUBTYPE_SPEC /= CONST_VOID then
                return SUBTYPE_SPEC;
            end if;
        end if;
        return TYPE_SPEC;
    end GET_SUBSTRUCT;

    function EVAL_TYPE_DEF
                ( TYPE_DEF: TREE
                ; ID: TREE
                ; H: H_TYPE
                ; DSCRMT_DECL_S: TREE := CONST_VOID )
            return TREE
    is

        TYPE_SPEC: TREE := CONST_VOID;
        BASE_TYPE: TREE := CONST_VOID;
        RECORD_REGION_DEF: TREE;
    begin

        if TYPE_DEF = CONST_VOID then
            return CONST_VOID;
        end if;

        -- get base type in case it is private, l_private or incomplete
        if KIND(ID) = DN_TYPE_ID
        and then D(SM_FIRST, ID) /= ID then
            BASE_TYPE := D(SM_TYPE_SPEC, D(SM_FIRST, ID));
        end if;

        case CLASS_TYPE_DEF'(KIND(TYPE_DEF)) is

        -- for an enumeration_type_declaration
        when DN_ENUMERATION_DEF =>
            declare
                ENUM_LITERAL_S: constant TREE := D(AS_ENUM_LITERAL_S, TYPE_DEF);
                ENUM_LITERAL_LIST: SEQ_TYPE := LIST(ENUM_LITERAL_S);
                ENUM_LITERAL: TREE;
                DEF, PRIOR_DEF: TREE;
                ENUM_LITERAL_COUNT: INTEGER := 0;
                ENUM_HEADER: TREE;
                PRIVATE_SPEC: TREE := D(SM_TYPE_SPEC, ID);
            begin

                -- create the enumeration node
                TYPE_SPEC := MAKE_ENUMERATION
                        ( SM_LITERAL_S => ENUM_LITERAL_S
                        , XD_SOURCE_NAME => ID );
                if BASE_TYPE = CONST_VOID then
                    BASE_TYPE := TYPE_SPEC;
                end if;
                D(SM_BASE_TYPE, TYPE_SPEC, BASE_TYPE);

                -- insert names in environment
                WALK_SOURCE_NAME_S(ENUM_LITERAL_S, H);

                -- make a header for the def nodes for the enum literals
                ENUM_HEADER := MAKE_FUNCTION_SPEC
                        ( AS_NAME => MAKE_USED_NAME_ID
                                ( LX_SYMREP => CONST_VOID
                                , SM_DEFN => ID )
                        , AS_PARAM_S => MAKE_PARAM_S (LIST => MAKE) );

                -- store type spec in type spec in type id
                -- ... (needed for get_prior_homograph_def)
                D(SM_TYPE_SPEC, ID, BASE_TYPE);

                -- for each enum_literal
                while not IS_EMPTY(ENUM_LITERAL_LIST) loop
                    POP(ENUM_LITERAL_LIST, ENUM_LITERAL);

                    -- store the base type
                    D(SM_OBJ_TYPE, ENUM_LITERAL, BASE_TYPE);

                    -- assign sm_pos and default sm_rep attributes
                    DI(SM_POS, ENUM_LITERAL, ENUM_LITERAL_COUNT);
                    DI(SM_REP, ENUM_LITERAL, ENUM_LITERAL_COUNT);
                    ENUM_LITERAL_COUNT := ENUM_LITERAL_COUNT + 1;

                    -- make def visible for this enum literal
                    DEF := GET_DEF_FOR_ID(ENUM_LITERAL);
                    MAKE_DEF_VISIBLE(DEF, ENUM_HEADER);

                    -- check for uniqueness
                    PRIOR_DEF := GET_PRIOR_HOMOGRAPH_DEF(DEF);
                    if PRIOR_DEF /= CONST_VOID
                    and then (not IS_OVERLOADABLE_HEADER(D(XD_HEADER,DEF))
                              or else EXPRESSION_TYPE_OF_DEF(DEF) = TYPE_SPEC)
                    then
                        ERROR(D(LX_SRCPOS,TYPE_DEF)
                                , "Enum literal is duplicate - "
                                  & PRINTNAME(D(LX_SYMREP, ENUM_LITERAL)) );
                        MAKE_DEF_IN_ERROR(DEF);
                    end if;
                end loop;

                -- construct sm_range attribute for the enumeration node
                D(SM_RANGE, TYPE_SPEC, MAKE_RANGE
                        ( SM_TYPE_SPEC => TYPE_SPEC
                        , AS_EXP1 => MAKE_USED_OBJECT_ID
                                ( SM_EXP_TYPE => TYPE_SPEC
                                , SM_DEFN => HEAD(LIST(ENUM_LITERAL_S))
                                , LX_SYMREP => D(LX_SYMREP
                                        , HEAD(LIST(ENUM_LITERAL_S)) )
                                , SM_VALUE => UARITH.U_VAL(0) )
                        , AS_EXP2 => MAKE_USED_OBJECT_ID
                                ( SM_EXP_TYPE => TYPE_SPEC
                                , SM_DEFN => ENUM_LITERAL
                                , LX_SYMREP => D(LX_SYMREP, ENUM_LITERAL)
                                , SM_VALUE => UARITH.U_VAL
                                        ( ENUM_LITERAL_COUNT - 1 ))));

                -- compute size and store in enumeration node
                if ENUM_LITERAL_COUNT > 2 ** 8 then
                    DI(CD_IMPL_SIZE, TYPE_SPEC, 16);
                else
                    DI(CD_IMPL_SIZE, TYPE_SPEC, 8);
                end if;

                -- restore type spec in type spec in type id
                -- ... (no longer needed for get_prior_homograph_def)
                if PRIVATE_SPEC /= CONST_VOID then
                    D(SM_TYPE_SPEC, ID, PRIVATE_SPEC);
                end if;
            end;


        -- for a subtype indication
        when DN_SUBTYPE_INDICATION =>
            declare
                SUBTYPE_INDICATION: TREE := TYPE_DEF;
                BASE_TYPE: TREE := EVAL_SUBTYPE_INDICATION(SUBTYPE_INDICATION);
            begin

                -- resolve subtype indication and get its subtype
                RESOLVE_SUBTYPE_INDICATION (SUBTYPE_INDICATION, TYPE_SPEC);

                -- return without modifying base type, etc.
                return TYPE_SPEC;
            end;


        -- for an integer_type_definition
        when DN_INTEGER_DEF =>
            declare
                use UARITH;

                RANGE_NODE:     constant TREE := D(AS_CONSTRAINT, TYPE_DEF);
                EXP1:           TREE := D(AS_EXP1, RANGE_NODE);
                EXP2:           TREE := D(AS_EXP2, RANGE_NODE);

                TYPESET_1:      TYPESET_TYPE;
                TYPESET_2:      TYPESET_TYPE;
                LOWER_BOUND:    TREE;
                UPPER_BOUND:    TREE;

                ANCESTOR_TYPE:  TREE;
                DERIVED_BASE:   TREE;
            begin

                -- evaluate the lower bound expression
                EVAL_EXP_TYPES(EXP1, TYPESET_1);
                REQUIRE_INTEGER_TYPE(EXP1, TYPESET_1);
                REQUIRE_UNIQUE_TYPE(EXP1, TYPESET_1);
                EXP1 := RESOLVE_EXP(EXP1, TYPESET_1);
                D(AS_EXP1, RANGE_NODE, EXP1);
                LOWER_BOUND := GET_STATIC_VALUE(EXP1);

                -- evaluate the upper bound expression
                EVAL_EXP_TYPES(EXP2, TYPESET_2);
                REQUIRE_INTEGER_TYPE(EXP2, TYPESET_2);
                REQUIRE_UNIQUE_TYPE(EXP2, TYPESET_2);
                EXP2 := RESOLVE_EXP(EXP2, TYPESET_2);
                D(AS_EXP2, RANGE_NODE, EXP2);
                UPPER_BOUND := GET_STATIC_VALUE(EXP2);

                -- if both bounds are static
                if LOWER_BOUND /= CONST_VOID and UPPER_BOUND /= CONST_VOID then

                    -- if range fits within short_integer
                    if LOWER_BOUND >= PREDEFINED_SHORT_INTEGER_FIRST
                    and UPPER_BOUND <= PREDEFINED_SHORT_INTEGER_LAST
                    and PREDEFINED_SHORT_INTEGER /= CONST_VOID then
                        -- use short_integer
                        ANCESTOR_TYPE := PREDEFINED_SHORT_INTEGER;

                    -- else if range fits within integer
                    elsif LOWER_BOUND >= PREDEFINED_INTEGER_FIRST
                    and UPPER_BOUND <= PREDEFINED_INTEGER_LAST then

                        -- use integer
                        ANCESTOR_TYPE := PREDEFINED_INTEGER;

                    -- else if range fits within long_integer
                    elsif LOWER_BOUND >= PREDEFINED_LONG_INTEGER_FIRST
                    and UPPER_BOUND <= PREDEFINED_LONG_INTEGER_LAST then

                        -- use long_integer
                        ANCESTOR_TYPE := PREDEFINED_LONG_INTEGER;

                    -- else -- since not within any predefined integer type
                    else

                        -- report error
                        ERROR( D(LX_SRCPOS, RANGE_NODE)
                              ,  "Integer type too large for implementation" );

                        -- assume largest integer type
                        ANCESTOR_TYPE := PREDEFINED_LARGEST_INTEGER;
                    end if;

                -- else -- since at least one bound is not static
                else

                    -- assume largest integer type
                    ANCESTOR_TYPE := PREDEFINED_LARGEST_INTEGER;

                    -- if lower bound is not static
                    -- ... and a type was determined for it
                    if LOWER_BOUND = CONST_VOID
                    and then not IS_EMPTY(TYPESET_1) then

                        -- indicate error
                        ERROR(D(LX_SRCPOS,EXP1), "Bounds must be static");
                    end if;

                    -- if upper bound is not static
                    -- ... and a type was determined for it
                    if UPPER_BOUND = CONST_VOID
                    and then not IS_EMPTY(TYPESET_2) then

                        -- indicate error
                        ERROR(D(LX_SRCPOS,EXP2), "Bounds must be static");
                    end if;
                end if;

                -- construct anonymous derived integer type
                DERIVED_BASE := COPY_NODE(ANCESTOR_TYPE);
                if BASE_TYPE = CONST_VOID then
                    BASE_TYPE := DERIVED_BASE;
                end if;
                D(SM_BASE_TYPE, DERIVED_BASE, BASE_TYPE);
                D(XD_SOURCE_NAME, DERIVED_BASE, ID);
                DB(SM_IS_ANONYMOUS, DERIVED_BASE, TRUE);
                D(SM_DERIVED, DERIVED_BASE, ANCESTOR_TYPE);

                -- construct subtype of anonymous type
                TYPE_SPEC := COPY_NODE(DERIVED_BASE);
                DB(SM_IS_ANONYMOUS, TYPE_SPEC, FALSE);
                D(SM_DERIVED, TYPE_SPEC, CONST_VOID);
                D(SM_RANGE, TYPE_SPEC, RANGE_NODE);

                -- make range type the new base type
                D(SM_TYPE_SPEC, RANGE_NODE, BASE_TYPE);
            end;


        -- for a floating_point_constraint used as real_type_definition
        when DN_FLOAT_DEF =>
            declare
                use UARITH;

                CONSTRAINT:     constant TREE := D(AS_CONSTRAINT, TYPE_DEF);
                EXP:            TREE := D(AS_EXP, CONSTRAINT);
                RANGE_NODE:     constant TREE := D(AS_RANGE, CONSTRAINT);
                EXP1:           TREE;
                EXP2:           TREE;

                TYPESET:        TYPESET_TYPE;
                TYPESET_1:      TYPESET_TYPE;
                TYPESET_2:      TYPESET_TYPE;
                ACCURACY:       TREE;
                LOWER_BOUND:    TREE;
                UPPER_BOUND:    TREE;

                ANCESTOR_TYPE:  TREE;
                DERIVED_BASE:   TREE;
            begin

                -- evaluate the accuracy expression
                EVAL_EXP_TYPES(EXP, TYPESET);
                REQUIRE_INTEGER_TYPE(EXP, TYPESET);
                REQUIRE_UNIQUE_TYPE(EXP, TYPESET);
                EXP := RESOLVE_EXP(EXP, TYPESET);
                D(AS_EXP, CONSTRAINT, EXP);
                ACCURACY := GET_STATIC_VALUE(EXP);

                -- if a range is given
                if RANGE_NODE /= CONST_VOID then

                    -- evaluate the lower bound expression
                    EXP1 := D(AS_EXP1, RANGE_NODE);
                    EVAL_EXP_TYPES(EXP1, TYPESET_1);
                    REQUIRE_REAL_TYPE(EXP1, TYPESET_1);
                    REQUIRE_UNIQUE_TYPE(EXP1, TYPESET_1);
                    EXP1 := RESOLVE_EXP(EXP1, TYPESET_1);
                    D(AS_EXP1, RANGE_NODE, EXP1);
                    LOWER_BOUND := GET_STATIC_VALUE(EXP1);

                    -- evaluate the upper bound expression
                    EXP2 := D(AS_EXP2, RANGE_NODE);
                    EVAL_EXP_TYPES(EXP2, TYPESET_2);
                    REQUIRE_REAL_TYPE(EXP2, TYPESET_2);
                    REQUIRE_UNIQUE_TYPE(EXP2, TYPESET_2);
                    EXP2 := RESOLVE_EXP(EXP2, TYPESET_2);
                    D(AS_EXP2, RANGE_NODE, EXP2);
                    UPPER_BOUND := GET_STATIC_VALUE(EXP2);
                end if;

                -- if accuracy and both bounds (if given) are static
                -- and accuracy is positive
                if ACCURACY /= CONST_VOID
                and then (RANGE_NODE = CONST_VOID
                          or else (LOWER_BOUND /= CONST_VOID
                                and then UPPER_BOUND /= CONST_VOID))
                and then not (ACCURACY <= U_VAL(0))
                then

                    -- if range fits within float
                    if ACCURACY <= PREDEFINED_FLOAT_ACCURACY
                    and then (RANGE_NODE = CONST_VOID
                              or else (LOWER_BOUND >= PREDEFINED_FLOAT_FIRST
                                    and then UPPER_BOUND
                                                <= PREDEFINED_FLOAT_LAST))
                    then

                        -- use float
                        ANCESTOR_TYPE := PREDEFINED_FLOAT;

                    -- if range fits within long_float
                    elsif ACCURACY <= PREDEFINED_LONG_FLOAT_ACCURACY
                    and then (RANGE_NODE = CONST_VOID
                              or else (LOWER_BOUND
                                                >= PREDEFINED_LONG_FLOAT_FIRST
                                    and then UPPER_BOUND
                                                <= PREDEFINED_LONG_FLOAT_LAST))
                    then

                        -- use long_float
                        ANCESTOR_TYPE := PREDEFINED_LONG_FLOAT;

                    -- else -- since too large for implementation
                    else

                        -- report error
                        ERROR( D(LX_SRCPOS, CONSTRAINT)
                               , "Floating type too large for implementation" );

                        -- assume largest floating type
                        ANCESTOR_TYPE := PREDEFINED_LARGEST_FLOAT;
                    end if;

                -- else -- since accuracy or at least one bound is not static
                else

                    -- assume largest floating type
                    ANCESTOR_TYPE := PREDEFINED_LARGEST_FLOAT;

                    -- if accuracy is not static
                    -- ... and a type was determined for it
                    if ACCURACY = CONST_VOID
                    and then not IS_EMPTY(TYPESET) then

                        -- indicate error
                        ERROR(D(LX_SRCPOS,EXP), "Accuracy must be static");
                    end if;

                    -- if a range was given
                    if RANGE_NODE /= CONST_VOID then

                        -- if lower bound is not static
                        -- ... and a type was determined for it
                        if LOWER_BOUND = CONST_VOID
                        and then not IS_EMPTY(TYPESET_1) then

                            -- indicate error
                            ERROR(D(LX_SRCPOS,EXP1), "Bounds must be static");
                        end if;

                        -- if upper bound is not static
                        -- ... and a type was determined for it
                        if UPPER_BOUND = CONST_VOID
                        and then not IS_EMPTY(TYPESET_2) then

                            -- indicate error
                            ERROR(D(LX_SRCPOS,EXP2), "Bounds must be static");
                        end if;
                    end if;
                end if;

                -- construct anonymous derived floating type
                DERIVED_BASE := COPY_NODE(ANCESTOR_TYPE);
                if BASE_TYPE = CONST_VOID then
                    BASE_TYPE := DERIVED_BASE;
                end if;
                D(SM_BASE_TYPE, DERIVED_BASE, BASE_TYPE);
                D(XD_SOURCE_NAME, DERIVED_BASE, ID);
                DB(SM_IS_ANONYMOUS, DERIVED_BASE, TRUE);
                D(SM_DERIVED, DERIVED_BASE, ANCESTOR_TYPE);

                -- make range type the new base type
                D(SM_TYPE_SPEC, CONSTRAINT, BASE_TYPE);

                -- construct subtype of anonymous type
                TYPE_SPEC := COPY_NODE(DERIVED_BASE);
                DB(SM_IS_ANONYMOUS, TYPE_SPEC, FALSE);
                D(SM_DERIVED, TYPE_SPEC, CONST_VOID);
                D(SM_ACCURACY, TYPE_SPEC, ACCURACY);
                D(SM_TYPE_SPEC, CONSTRAINT, BASE_TYPE);
                if RANGE_NODE /= CONST_VOID then
                    D(SM_RANGE, TYPE_SPEC, RANGE_NODE);
                    D(SM_TYPE_SPEC, RANGE_NODE, BASE_TYPE);
                else
                    D(SM_RANGE, TYPE_SPEC, D(SM_RANGE, ANCESTOR_TYPE));
                end if;
            end;


        -- for a fixed_point_constraint used as real_type_definition
        when DN_FIXED_DEF =>
            declare
                use UARITH;

                CONSTRAINT:     constant TREE := D(AS_CONSTRAINT, TYPE_DEF);
                EXP:            TREE := D(AS_EXP, CONSTRAINT);
                RANGE_NODE:     constant TREE := D(AS_RANGE, CONSTRAINT);
                EXP1:           TREE;
                EXP2:           TREE;

                TYPESET:        TYPESET_TYPE;
                TYPESET_1:      TYPESET_TYPE;
                TYPESET_2:      TYPESET_TYPE;
                ACCURACY:       TREE;
                LOWER_BOUND:    TREE;
                UPPER_BOUND:    TREE;

                ANCESTOR_TYPE:  TREE;
                DERIVED_BASE:   TREE;
                POWER_31:       constant TREE := U_VAL(2) ** U_VAL(31);
            begin

                -- evaluate the accuracy expression
                EVAL_EXP_TYPES(EXP, TYPESET);
                REQUIRE_REAL_TYPE(EXP, TYPESET);
                REQUIRE_UNIQUE_TYPE(EXP, TYPESET);
                EXP := RESOLVE_EXP(EXP, TYPESET);
                D(AS_EXP, CONSTRAINT, EXP);
                ACCURACY := GET_STATIC_VALUE(EXP);

                -- if accuracy is not static
                if ACCURACY = CONST_VOID then

                    -- put out error message
                    ERROR(D(LX_SRCPOS,EXP), "Fixed accuracy must be static");

                -- else if accuracy is not positive
                elsif D(XD_NUMER,ACCURACY) <= U_VAL(0) then

                    -- put out error message
                    ERROR(D(LX_SRCPOS,EXP), "Fixed accuracy must positive");

                    -- and pretend it was not static (for later tests)
                    ACCURACY := CONST_VOID;
                end if;


                -- if no range is given
                if RANGE_NODE = CONST_VOID then

                    -- indicate error
                    ERROR(D(LX_SRCPOS, CONSTRAINT), "Range required");

                    -- and return void to indicate error to caller
                    return CONST_VOID;
                end if;

                -- evaluate the lower bound expression
                EXP1 := D(AS_EXP1, RANGE_NODE);
                EVAL_EXP_TYPES(EXP1, TYPESET_1);
                REQUIRE_REAL_TYPE(EXP1, TYPESET_1);
                REQUIRE_UNIQUE_TYPE(EXP1, TYPESET_1);
                EXP1 := RESOLVE_EXP(EXP1, TYPESET_1);
                D(AS_EXP1, RANGE_NODE, EXP1);
                LOWER_BOUND := GET_STATIC_VALUE(EXP1);

                -- evaluate the upper bound expression
                EXP2 := D(AS_EXP2, RANGE_NODE);
                EVAL_EXP_TYPES(EXP2, TYPESET_2);
                REQUIRE_REAL_TYPE(EXP2, TYPESET_2);
                REQUIRE_UNIQUE_TYPE(EXP2, TYPESET_2);
                EXP2 := RESOLVE_EXP(EXP2, TYPESET_2);
                D(AS_EXP2, RANGE_NODE, EXP2);
                UPPER_BOUND := GET_STATIC_VALUE(EXP2);

                -- if range and bounds are not static
                if ACCURACY = CONST_VOID
                or LOWER_BOUND = CONST_VOID
                or UPPER_BOUND = CONST_VOID then

                    -- if lower bound is not static
                    if LOWER_BOUND = CONST_VOID then

                        -- put out error message
                        ERROR(D(LX_SRCPOS,EXP1), "Lower bound must be static");

                    -- if upper bound is not static
                    end if;
                    if UPPER_BOUND = CONST_VOID then

                        -- put out error message
                        ERROR(D(LX_SRCPOS,EXP1), "Upper bound must be static");

                    -- and return void to indicate error to caller
                    end if;
                    return CONST_VOID;
                end if;


                -- if bounds fit within 32-bit fixed type
                if UPPER_BOUND <= ACCURACY * POWER_31
                and LOWER_BOUND >= - ACCURACY * POWER_31 - ACCURACY
                then

                    -- use given bounds
                    null;

                -- else -- since bounds do not fit
                else

                    -- put out error message
                    ERROR(D(LX_SRCPOS, CONSTRAINT), "Fixed type too large");

                    -- return void to indicate error
                    return CONST_VOID;
                end if;


                -- construct anonymous fixed type
                DERIVED_BASE := MAKE_FIXED
                        ( XD_SOURCE_NAME => ID
                        , SM_IS_ANONYMOUS => TRUE
                        , SM_RANGE => MAKE_RANGE
                                ( SM_TYPE_SPEC => BASE_TYPE
                                , AS_EXP1 => MAKE_USED_OBJECT_ID
                                        ( LX_SYMREP => CONST_VOID
                                        , SM_VALUE => - POWER_31 * ACCURACY
                                        , SM_EXP_TYPE => BASE_TYPE )
                                , AS_EXP2 => MAKE_USED_OBJECT_ID
                                        ( LX_SYMREP => CONST_VOID
                                        , SM_VALUE
                                               => POWER_31 * ACCURACY - ACCURACY
                                        , SM_EXP_TYPE => BASE_TYPE ) )
                        , CD_IMPL_SIZE => 32
                        , SM_ACCURACY => ACCURACY
                        , CD_IMPL_SMALL => ACCURACY );
                if BASE_TYPE = CONST_VOID then
                    BASE_TYPE := DERIVED_BASE;
                end if;
                D(SM_BASE_TYPE, DERIVED_BASE, BASE_TYPE);

                -- construct subtype of anonymous type
                TYPE_SPEC := COPY_NODE(DERIVED_BASE);
                DB(SM_IS_ANONYMOUS, TYPE_SPEC, FALSE);
                D(SM_DERIVED, TYPE_SPEC, CONST_VOID);
                D(SM_RANGE, TYPE_SPEC, RANGE_NODE);
                D(SM_ACCURACY, TYPE_SPEC, ACCURACY);

                -- make range type the new base type
                D(SM_TYPE_SPEC, CONSTRAINT, BASE_TYPE);
                D(SM_TYPE_SPEC, RANGE_NODE, BASE_TYPE);
                D(SM_TYPE_SPEC, D(SM_RANGE,DERIVED_BASE), BASE_TYPE);
            end;


        -- for a constrained_array_definition
        when DN_CONSTRAINED_ARRAY_DEF =>
            declare
                SUBTYPE_INDICATION: TREE := D(AS_SUBTYPE_INDICATION, TYPE_DEF);
                CONSTRAINT: TREE := D(AS_CONSTRAINT, TYPE_DEF);

                COMP_TYPE: TREE;

                INDEX_EXP_LIST: SEQ_TYPE
                        := LIST(D(AS_DISCRETE_RANGE_S,CONSTRAINT));
                INDEX_EXP:      TREE;
                INDEX_BASE_TYPE: TREE;
                INDEX_SUBTYPE:  TREE;
                INDEX_TYPE_MARK:TREE;

                TYPESET: TYPESET_TYPE;

                DISCRETE_RANGE_LIST: SEQ_TYPE := MAKE;
                INDEX_LIST: SEQ_TYPE := MAKE;
                SCALAR_LIST: SEQ_TYPE := MAKE;
            begin
                COMP_TYPE := EVAL_SUBTYPE_INDICATION(SUBTYPE_INDICATION);
                RESOLVE_SUBTYPE_INDICATION(SUBTYPE_INDICATION, COMP_TYPE);

                while not IS_EMPTY(INDEX_EXP_LIST) loop
                    POP(INDEX_EXP_LIST, INDEX_EXP);
                    EVAL_NON_UNIVERSAL_DISCRETE_RANGE
                                ( INDEX_EXP, TYPESET);
                    REQUIRE_UNIQUE_TYPE(INDEX_EXP, TYPESET);
                    INDEX_BASE_TYPE := GET_THE_TYPE(TYPESET);
                    INDEX_EXP := RESOLVE_DISCRETE_RANGE
                                ( INDEX_EXP, INDEX_BASE_TYPE );
                    DISCRETE_RANGE_LIST := APPEND
                                ( DISCRETE_RANGE_LIST, INDEX_EXP);

                    if INDEX_BASE_TYPE /= CONST_VOID then
                        INDEX_SUBTYPE :=
                                GET_SUBTYPE_OF_DISCRETE_RANGE(INDEX_EXP);
                    else
                        INDEX_SUBTYPE := CONST_VOID;
                    end if;

                    SCALAR_LIST := APPEND(SCALAR_LIST, INDEX_SUBTYPE);
                    INDEX_LIST := APPEND(INDEX_LIST, MAKE_INDEX
                            ( AS_NAME => CONST_VOID
                            , SM_TYPE_SPEC => INDEX_SUBTYPE ) );
                end loop;
                LIST(D(AS_DISCRETE_RANGE_S, CONSTRAINT), DISCRETE_RANGE_LIST);

                BASE_TYPE := MAKE_ARRAY
                        ( SM_COMP_TYPE => COMP_TYPE
                        , SM_INDEX_S => MAKE_INDEX_S
                                ( LIST => INDEX_LIST )
                        , SM_IS_ANONYMOUS => TRUE
                        , XD_SOURCE_NAME => ID );
                D(SM_BASE_TYPE, BASE_TYPE, BASE_TYPE);

                TYPE_SPEC := MAKE_CONSTRAINED_ARRAY
                        ( SM_INDEX_SUBTYPE_S => MAKE_SCALAR_S
                                ( LIST => SCALAR_LIST )
                        , SM_BASE_TYPE => BASE_TYPE );

                -- if this def was part of a variable declaration
                if KIND(ID) = DN_VARIABLE_ID then

                    -- mark type_spec anonymous
                    DB(SM_IS_ANONYMOUS, TYPE_SPEC, TRUE);
                end if;
            end;


        -- for an unconstrained array definition
        when DN_UNCONSTRAINED_ARRAY_DEF =>
            declare
                SUBTYPE_INDICATION: TREE := D(AS_SUBTYPE_INDICATION, TYPE_DEF);
                INDEX_S: TREE := D(AS_INDEX_S, TYPE_DEF);

                COMP_TYPE: TREE;
                INDEX_LIST: SEQ_TYPE := LIST(INDEX_S);
                INDEX: TREE;
                TYPE_MARK: TREE;
                TYPE_DEFN: TREE;

                ERROR_SEEN: BOOLEAN := FALSE;
            begin

                -- evaluate component type
                COMP_TYPE := EVAL_SUBTYPE_INDICATION(SUBTYPE_INDICATION);
                RESOLVE_SUBTYPE_INDICATION(SUBTYPE_INDICATION, COMP_TYPE);

                -- remember if in error
                if COMP_TYPE = CONST_VOID then
                    ERROR_SEEN := TRUE;
                end if;

                -- for each index
                while not IS_EMPTY(INDEX_LIST) loop
                    POP(INDEX_LIST, INDEX);

                    -- evaluate the type mark
                    TYPE_MARK := D(AS_NAME, INDEX);
                    TYPE_MARK := WALK_TYPE_MARK(TYPE_MARK);
                    D(AS_NAME, INDEX, TYPE_MARK);

                    -- if type mark was accepted
                    if TYPE_MARK /= CONST_VOID then

                        --store index subtype in index node
                        D(SM_TYPE_SPEC
                                , INDEX
                                , D(SM_TYPE_SPEC, GET_NAME_DEFN(TYPE_MARK)));
                        --$$$$ ???? check this

                    -- else -- since type mark was in error
                    else

                        -- remember that there was an error
                        ERROR_SEEN := TRUE;
                    end if;
                end loop;

                -- if definition was correct
                if not ERROR_SEEN then

                    -- make array node
                    TYPE_SPEC := MAKE_ARRAY
                                ( SM_COMP_TYPE => COMP_TYPE
                                , SM_INDEX_S => INDEX_S );

                    -- make sure it is its own base type
                    BASE_TYPE := TYPE_SPEC;
                end if;
            end;


        -- for an access type definition
        when DN_ACCESS_DEF =>
            declare
                SUBTYPE_INDICATION: TREE := D(AS_SUBTYPE_INDICATION, TYPE_DEF);

                DESIG_TYPE: TREE;
            begin
                -- evaluate the designated type
                DESIG_TYPE := EVAL_SUBTYPE_INDICATION(SUBTYPE_INDICATION);
                RESOLVE_SUBTYPE_INDICATION(SUBTYPE_INDICATION, DESIG_TYPE);

                -- if designated type declaration was correct
                if DESIG_TYPE /= CONST_VOID then

                    -- construct an access node
                    TYPE_SPEC := MAKE_ACCESS
                                    ( SM_DESIG_TYPE => DESIG_TYPE
                                    , XD_SOURCE_NAME => ID );
                    BASE_TYPE := TYPE_SPEC;
                    D(SM_BASE_TYPE, TYPE_SPEC, TYPE_SPEC);

                    -- if subtype indication contains a constraint
                    -- $$$$ worry about constrained desig type

                    if KIND(SUBTYPE_INDICATION) = DN_SUBTYPE_INDICATION
                    and then D(AS_CONSTRAINT, SUBTYPE_INDICATION) /= CONST_VOID
                    then

                        -- construct a constrained_access node
                        TYPE_SPEC := MAKE_CONSTRAINED_ACCESS
                                    ( SM_DESIG_TYPE => DESIG_TYPE
                                    , SM_BASE_TYPE => TYPE_SPEC
                                    , XD_SOURCE_NAME => ID );

                    end if;
                end if;
            end;


        when DN_DERIVED_DEF =>
            declare
                SUBTYPE_INDICATION: TREE := D(AS_SUBTYPE_INDICATION, TYPE_DEF);

                PARENT_SUBTYPE: TREE;
                PARENT_TYPE: TREE;

                SUBTYPE_SPEC: TREE;
            begin
                -- evaluate the parent type
                PARENT_TYPE := EVAL_SUBTYPE_INDICATION(SUBTYPE_INDICATION);
                parent_type := get_base_struct(parent_type);
                RESOLVE_SUBTYPE_INDICATION(SUBTYPE_INDICATION, PARENT_SUBTYPE);

                -- check that parent type is derivable at this point
                if KIND(PARENT_TYPE) not in CLASS_DERIVABLE_SPEC then
                    if KIND(PARENT_TYPE) = DN_INCOMPLETE
                    and then D(XD_FULL_TYPE_SPEC, PARENT_TYPE) /= CONST_VOID
                    then
                        null;
                    else
                        ERROR(D(LX_SRCPOS,SUBTYPE_INDICATION),
                                "Type is not derivable here");
                        PARENT_TYPE := CONST_VOID;
                    end if;
                end if;

                -- if parent type declaration was not correct
                if PARENT_TYPE = CONST_VOID then

                    -- return void to indicate error
                    return CONST_VOID;
                end if;

                -- make derived type spec
                TYPE_SPEC := COPY_NODE(GET_BASE_STRUCT(PARENT_TYPE));
                D(XD_SOURCE_NAME, TYPE_SPEC, ID);
                if BASE_TYPE = CONST_VOID then
                    BASE_TYPE := TYPE_SPEC;
                end if;
                D(SM_DERIVED, TYPE_SPEC, PARENT_TYPE);

                -- if type is an enumeration type (and not generic (<>))
                if KIND(TYPE_SPEC) = DN_ENUMERATION
                and then D(SM_LITERAL_S,TYPE_SPEC) /= CONST_VOID then

                    -- copy the enumeration literals
                    declare
                        ENUM_LITERAL_LIST: SEQ_TYPE
                                        := LIST(D(SM_LITERAL_S,TYPE_SPEC));
                        ENUM_LITERAL: TREE;
                        NEW_LIST: SEQ_TYPE := MAKE;
                        TEMP_DEF: TREE;

                        ENUM_HEADER: TREE;
                    begin
                        -- make a header for the def nodes for the enum literals
                        ENUM_HEADER := MAKE_FUNCTION_SPEC
                                ( AS_NAME => MAKE_USED_NAME_ID
                                        ( LX_SYMREP => CONST_VOID
                                        , SM_DEFN => ID )
                                , AS_PARAM_S => MAKE_PARAM_S (LIST => MAKE) );

                        -- for each literal
                        while not IS_EMPTY(ENUM_LITERAL_LIST) loop
                            POP(ENUM_LITERAL_LIST, ENUM_LITERAL);

                            -- make a new copy of it
                            ENUM_LITERAL := COPY_NODE(ENUM_LITERAL);
                            if KIND(D(LX_SYMREP,ENUM_LITERAL)) = DN_SYMBOL_REP
                            then
                                TEMP_DEF := MAKE_DEF_FOR_ID(ENUM_LITERAL, H);
                                MAKE_DEF_VISIBLE(TEMP_DEF, ENUM_HEADER);
                            else
                                D(XD_REGION, ENUM_LITERAL
                                        , D(XD_SOURCE_NAME,H.REGION_DEF));
                            end if;
                            D(LX_SRCPOS, ENUM_LITERAL, CONST_VOID);
                            D(SM_OBJ_TYPE, ENUM_LITERAL, BASE_TYPE);
                            NEW_LIST := APPEND(NEW_LIST, ENUM_LITERAL);
                        end loop;

                        D(SM_LITERAL_S
                                , TYPE_SPEC
                                , MAKE_ENUM_LITERAL_S(LIST => NEW_LIST) );
                    end;

                -- else if type is a record or task type
                elsif KIND(TYPE_SPEC) = DN_RECORD
                or else KIND(TYPE_SPEC) = DN_TASK_SPEC then

                  declare
                    H: H_TYPE := EVAL_TYPE_DEF.H;
                    S: S_TYPE;
                    node_hash: node_hash_type;

                  begin

                    -- enter record declarative region
                    RECORD_REGION_DEF := GET_DEF_FOR_ID(ID);
                    ENTER_REGION(RECORD_REGION_DEF, H, S);

                    -- copy the record structure using generic substitution
                    substitute_attributes(type_spec, node_hash, h);

                    -- leave record declarative region
                    LEAVE_REGION(RECORD_REGION_DEF, S);
                  end;

                -- else if type is [limited] private
                elsif KIND(TYPE_SPEC) in CLASS_PRIVATE_SPEC then

                  declare
                    H: H_TYPE := EVAL_TYPE_DEF.H;
                    S: S_TYPE;
                  begin

                    -- kill full type spec (since derived is private)
                    d(sm_type_spec, type_spec, const_void);

                    -- enter record declarative region
                    RECORD_REGION_DEF := GET_DEF_FOR_ID(ID);
                    ENTER_REGION(RECORD_REGION_DEF, H, S);

                    -- copy the discriminant names
                    D(SM_DISCRIMINANT_S
                                , TYPE_SPEC
                                , COPY_ITEM_S_IDS
                                        ( D(SM_DISCRIMINANT_S, TYPE_SPEC)
                                        , H ) );

                    -- leave record declarative region
                    LEAVE_REGION(RECORD_REGION_DEF, S);
                  end;

                -- else if type is array
                elsif KIND(TYPE_SPEC) = DN_ARRAY then

                    -- use type as base type, even for private
                    BASE_TYPE := TYPE_SPEC;
                end if;


                -- if parent type has a constraint
                if PARENT_SUBTYPE /= PARENT_TYPE then

                    -- make the new base type anonymous
                    DB(SM_IS_ANONYMOUS, TYPE_SPEC, TRUE);

                    -- fix up base type of type spec
                    if KIND(BASE_TYPE) in CLASS_NON_TASK then
                        D(SM_BASE_TYPE, TYPE_SPEC, BASE_TYPE);
                    end if;

                    -- copy the parent subtype
                    SUBTYPE_SPEC := COPY_NODE(PARENT_SUBTYPE);

                    -- fix up subtype node
                    D(XD_SOURCE_NAME, SUBTYPE_SPEC, ID);

                    -- replace result with subtype
                    TYPE_SPEC := SUBTYPE_SPEC;
                end if;

                -- add base type and source name
                -- (done again after the case statement; needed for deriv subp)
                if KIND(TYPE_SPEC) in CLASS_NON_TASK then
                    D(SM_BASE_TYPE, TYPE_SPEC, BASE_TYPE);
                end if;
                D(XD_SOURCE_NAME, TYPE_SPEC, ID);

                -- create derived subprograms
                LIST(TYPE_DEF, DERIVED.MAKE_DERIVED_SUBPROGRAM_LIST
                        ( GET_BASE_TYPE(TYPE_SPEC)
                        , GET_BASE_TYPE(PARENT_SUBTYPE)
                        , H ) );
            end;


        when DN_RECORD_DEF =>
            declare
                COMP_LIST: constant TREE := D(AS_COMP_LIST, TYPE_DEF);

                H: H_TYPE := EVAL_TYPE_DEF.H;
                S: S_TYPE;
            begin
                TYPE_SPEC := MAKE_RECORD
                                ( XD_SOURCE_NAME => ID
                                , SM_DISCRIMINANT_S => DSCRMT_DECL_S
                                , SM_COMP_LIST => COMP_LIST );

                -- enter record declarative region
                RECORD_REGION_DEF := GET_DEF_FOR_ID(ID);
                ENTER_REGION(RECORD_REGION_DEF, H, S);

                -- walk the component list
                WALK_COMP_LIST(COMP_LIST, H);

                -- leave record declarative region
                LEAVE_REGION(RECORD_REGION_DEF, S);
            end;


        when DN_PRIVATE_DEF =>
            TYPE_SPEC := MAKE_PRIVATE;
            D(SM_DISCRIMINANT_S, TYPE_SPEC, DSCRMT_DECL_S);


        when DN_L_PRIVATE_DEF =>
            TYPE_SPEC := MAKE_L_PRIVATE;
            D(SM_DISCRIMINANT_S, TYPE_SPEC, DSCRMT_DECL_S);


        when DN_FORMAL_DSCRT_DEF =>
            TYPE_SPEC := MAKE_ENUMERATION
                        ( SM_LITERAL_S => MAKE_ENUM_LITERAL_S(MAKE) );

        when DN_FORMAL_INTEGER_DEF =>
            TYPE_SPEC := MAKE_INTEGER;


        when DN_FORMAL_FIXED_DEF =>
            TYPE_SPEC := MAKE_FIXED;


        when DN_FORMAL_FLOAT_DEF =>
            TYPE_SPEC := MAKE_FLOAT;

        end case;


        -- if type definition was in error
        if TYPE_SPEC = CONST_VOID then

            -- return void to indicate error
            return CONST_VOID;
        end if;

        -- add base type and source name
        if BASE_TYPE = CONST_VOID then
            BASE_TYPE := TYPE_SPEC;
        end if;
        if KIND(TYPE_SPEC) in CLASS_NON_TASK then
            D(SM_BASE_TYPE, TYPE_SPEC, BASE_TYPE);
        end if;
        D(XD_SOURCE_NAME, TYPE_SPEC, ID);

        -- return the constructed type_spec
        return TYPE_SPEC;
    end EVAL_TYPE_DEF;


    function COPY_COMP_LIST_IDS(COMP_LIST: TREE; H: H_TYPE) return TREE is
        DECL_S: TREE := D(AS_DECL_S, COMP_LIST);
        VARIANT_PART: TREE := D(AS_VARIANT_PART, COMP_LIST);
        NEW_COMP_LIST: TREE := COPY_NODE(COMP_LIST);
        VARIANT_S: TREE;
        VARIANT_LIST: SEQ_TYPE;
        VARIANT: TREE;
        NEW_VARIANT_LIST: SEQ_TYPE;
    begin
        D(LX_SRCPOS, NEW_COMP_LIST, CONST_VOID);

        DECL_S := COPY_ITEM_S_IDS(DECL_S, H);
        D(AS_DECL_S, NEW_COMP_LIST, DECL_S);

        if VARIANT_PART /= CONST_VOID then
            VARIANT_PART := COPY_NODE(VARIANT_PART);
            D(LX_SRCPOS, VARIANT_PART, CONST_VOID);
            D(AS_VARIANT_PART, NEW_COMP_LIST, VARIANT_PART);
            VARIANT_S := COPY_NODE(D(AS_VARIANT_S, VARIANT_PART));
            D(LX_SRCPOS, VARIANT_S, CONST_VOID);
            D(AS_VARIANT_S, VARIANT_PART, VARIANT_S);
            VARIANT_LIST := LIST(VARIANT_S);
            while not IS_EMPTY(VARIANT_LIST) loop
                POP(VARIANT_LIST, VARIANT);
                if KIND(VARIANT) = DN_VARIANT then
                    VARIANT := COPY_NODE(VARIANT);
                    D(LX_SRCPOS, VARIANT, CONST_VOID);
                    D(AS_COMP_LIST
                            , VARIANT
                            , COPY_COMP_LIST_IDS(D(AS_COMP_LIST,VARIANT), H) );
                    NEW_VARIANT_LIST := APPEND(NEW_VARIANT_LIST, VARIANT);
                end if;
            end loop;
            LIST(VARIANT_S, NEW_VARIANT_LIST);
        end if;

        D(AS_PRAGMA_S, NEW_COMP_LIST, CONST_VOID);

        return NEW_COMP_LIST;
    end COPY_COMP_LIST_IDS;


    function COPY_ITEM_S_IDS(ITEM_S: TREE; H: H_TYPE) return TREE is
        NEW_ITEM_S: TREE;
        ITEM_LIST: SEQ_TYPE;
        ITEM: TREE;
        NEW_ITEM_LIST: SEQ_TYPE := MAKE;

        SOURCE_NAME_S: TREE;
        ID_LIST: SEQ_TYPE;
        ID: TREE;
        ID_DEF: TREE;
        NEW_ID_LIST: SEQ_TYPE;
    begin
        if ITEM_S = CONST_VOID then
            return CONST_VOID;
        end if;

        NEW_ITEM_S := COPY_NODE(ITEM_S);
        ITEM_LIST := LIST(NEW_ITEM_S);

        D(LX_SRCPOS, NEW_ITEM_S, CONST_VOID);
        while not IS_EMPTY(ITEM_LIST) loop
            POP(ITEM_LIST, ITEM);
            if KIND(ITEM) in CLASS_DSCRMT_PARAM_DECL'FIRST
                             .. CLASS_ID_S_DECL'LAST
            then
                ITEM := COPY_NODE(ITEM);
                D(LX_SRCPOS, ITEM, CONST_VOID);
                NEW_ITEM_LIST := APPEND(NEW_ITEM_LIST, ITEM);

                SOURCE_NAME_S := COPY_NODE(D(AS_SOURCE_NAME_S, ITEM));
                D(LX_SRCPOS, SOURCE_NAME_S, CONST_VOID);
                D(AS_SOURCE_NAME_S, ITEM, SOURCE_NAME_S);

                ID_LIST := LIST(SOURCE_NAME_S);
                NEW_ID_LIST := MAKE;
                while not IS_EMPTY(ID_LIST) loop
                    POP(ID_LIST, ID);
                    ID := COPY_NODE(ID);
                    D(LX_SRCPOS, ID, CONST_VOID);
                    if KIND(D(LX_SYMREP,ID)) = DN_SYMBOL_REP then
                        ID_DEF := MAKE_DEF_FOR_ID(ID, H);
                        MAKE_DEF_VISIBLE(ID_DEF);
                    else
                        D(XD_REGION, ID, H.REGION_DEF);
                    end if;
                    NEW_ID_LIST := APPEND(NEW_ID_LIST, ID);
                end loop;
                LIST(SOURCE_NAME_S, NEW_ID_LIST);

            elsif KIND(ITEM) = DN_NULL_COMP_DECL then
                NEW_ITEM_LIST := APPEND(NEW_ITEM_LIST, ITEM);
            end if;

        end loop;
        LIST(NEW_ITEM_S, NEW_ITEM_LIST);
        return NEW_ITEM_S;
    end COPY_ITEM_S_IDS;


    function GET_SUBTYPE_OF_DISCRETE_RANGE(DISCRETE_RANGE: TREE) return TREE is
        RESULT: TREE;
    begin
        case KIND(DISCRETE_RANGE) is
        when DN_RANGE =>
            RESULT := COPY_NODE
                        ( GET_BASE_STRUCT(D(SM_TYPE_SPEC, DISCRETE_RANGE)) );
            if KIND(RESULT) in DN_ENUMERATION .. DN_INTEGER then
                D(SM_RANGE, RESULT, DISCRETE_RANGE);
                D(SM_DERIVED, RESULT, CONST_VOID);
                DB(SM_IS_ANONYMOUS, RESULT, TRUE);
            else
                RESULT := CONST_VOID;
            end if;
            return RESULT;
        when DN_RANGE_ATTRIBUTE =>
            declare
                PREFIX: TREE := D(AS_NAME, DISCRETE_RANGE);
                PREFIX_SUBTYPE: TREE;
                WHICH_SUBSCRIPT: INTEGER := 1;
                INDEX_LIST: SEQ_TYPE;
                INDEX: TREE;
            begin
                if D(AS_EXP, DISCRETE_RANGE) /= CONST_VOID then
                    if GET_STATIC_VALUE(D(AS_EXP,DISCRETE_RANGE)) /= CONST_VOID
                    then
                        WHICH_SUBSCRIPT
                                := DI(SM_VALUE,D(AS_EXP,DISCRETE_RANGE));
                    else
                        WHICH_SUBSCRIPT := -1;
                    end if;
                end if;
                if KIND(PREFIX) = DN_SELECTED then
                    PREFIX := D(AS_DESIGNATOR,PREFIX);
                end if;
                if KIND(PREFIX) = DN_USED_NAME_ID then
                    -- it's a type mark
                    PREFIX_SUBTYPE := D(SM_TYPE_SPEC,D(SM_DEFN,PREFIX));
                else
                    PREFIX_SUBTYPE := D(SM_EXP_TYPE,PREFIX);
                    if KIND(GET_BASE_STRUCT(PREFIX_SUBTYPE)) = DN_ACCESS then
                        PREFIX_SUBTYPE := D(SM_DESIG_TYPE
                                , GET_SUBSTRUCT(PREFIX_SUBTYPE) );
                    end if;
                end if;
                PREFIX_SUBTYPE := GET_SUBSTRUCT(PREFIX_SUBTYPE);
                if KIND(PREFIX_SUBTYPE) = DN_CONSTRAINED_ARRAY then
                    INDEX_LIST := LIST(D(SM_INDEX_SUBTYPE_S, PREFIX_SUBTYPE));
                elsif KIND(PREFIX_SUBTYPE) = DN_ARRAY then
                    INDEX_LIST := LIST(D(SM_INDEX_S, PREFIX_SUBTYPE));
                else
                    INDEX_LIST := MAKE;
                end if;
                loop
                    if IS_EMPTY(INDEX_LIST) then
                        -- (Error already reported)
                        return CONST_VOID;
                    end if;
                    POP(INDEX_LIST, INDEX);
                    WHICH_SUBSCRIPT := WHICH_SUBSCRIPT - 1;
                    exit
                        when WHICH_SUBSCRIPT = 0;
                end loop;
                if KIND(INDEX) = DN_INDEX then
                    return D(SM_TYPE_SPEC, INDEX);
                else
                    return INDEX;
                end if;
            end;
        when DN_DISCRETE_SUBTYPE =>
            declare
                SUBTYPE_INDICATION: constant TREE
                            := D(AS_SUBTYPE_INDICATION, DISCRETE_RANGE);
                CONSTRAINT: constant TREE
                            := D(AS_CONSTRAINT, SUBTYPE_INDICATION);
                NAME_DEFN: TREE;
            begin
                if KIND(CONSTRAINT) = DN_RANGE then
                    return GET_SUBTYPE_OF_DISCRETE_RANGE(CONSTRAINT);
                else
                    NAME_DEFN := GET_NAME_DEFN(D(AS_NAME,SUBTYPE_INDICATION));
                    if NAME_DEFN /= CONST_VOID then
                        return D(SM_TYPE_SPEC,NAME_DEFN);
                    else
                        return CONST_VOID;
                    end if;
                end if;
            end;
        when others =>
            QUIT("invalid discrete range");
        end case;
    end GET_SUBTYPE_OF_DISCRETE_RANGE;


    procedure WALK_COMP_LIST (COMP_LIST: TREE; H: H_TYPE) is
        -- Walk the component list (fixed part + variant part + pragmas)
        -- ... in a record declaration or [recursively] in a variant part
        -- ... (called from eval_type_def for record declaration)

        DECL_S:         constant TREE := D(AS_DECL_S, COMP_LIST);
        VARIANT_PART:   constant TREE := D(AS_VARIANT_PART, COMP_LIST);
        PRAGMA_S:       constant TREE := D(AS_PRAGMA_S, COMP_LIST);

    begin

        -- Walk the fixed part
        WALK_ITEM_S(DECL_S, H);

        -- if there is a variant part
        if VARIANT_PART /= CONST_VOID then

            declare
                NAME:           TREE := D(AS_NAME, VARIANT_PART);
                VARIANT_S:      constant TREE := D(AS_VARIANT_S, VARIANT_PART);

                NAME_TYPE:      TREE;
                VARIANT_LIST:   SEQ_TYPE := LIST(VARIANT_S);
                VARIANT: TREE;
            begin
                -- $$$$ need to allow discriminant names at appropriate points

                -- evaluate the discriminant name
                -- ... (Syntax requires simple name)
                NAME := WALK_NAME(DN_DISCRIMINANT_ID, NAME);
                NAME_TYPE := GET_BASE_TYPE(NAME);

                -- for each variant or pragma
                while not IS_EMPTY(VARIANT_LIST) loop
                    POP(VARIANT_LIST, VARIANT);

                    -- if it is a variant
                    if KIND(VARIANT) = DN_VARIANT then

                        -- walk the choice list
                        WALK_DISCRETE_CHOICE_S
                                ( D(AS_CHOICE_S, VARIANT)
                                , NAME_TYPE );

                        -- walk the variant component list
                        WALK_COMP_LIST(D(AS_COMP_LIST, VARIANT), H);

                    -- else -- since it must be a variant_pragma
                    else

                        -- walk the pragma
                        WALK(D(AS_PRAGMA,VARIANT), H);
                    end if;
                end loop;
            end;
        end if;

        -- Walk the pragma part
        WALK_ITEM_S(PRAGMA_S, H);
    end WALK_COMP_LIST;

end DEFWALK;
