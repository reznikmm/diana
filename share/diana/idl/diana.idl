@@--DIANA.IDL 18-Jan-89

@@--Structure Diana
@@--Root COMPILATION Is

@@--Type source_position;	-- Source_Position
@@--Type comments;		-- Comments (not represented)
@@--Type symbol_rep;		-- symbol-rep
@@--Type value; 		-- Value -- VAL_CLASS
@@--Type operator;              -- Operator -- Bltn_Operators'POS
@@--Type number_rep;		-- Number_Rep -- symbol_rep

%terminals -------------------------------------------------------------

  ABORT ABS ACCEPT  ACCESS ALL	AND ARRAY  AT BEGIN  BODY CASE	CONSTANT
  DECLARE DELAY DELTA DIGITS DO ELSE ELSIF END	ENTRY EXCEPTION EXIT FOR
  FUNCTION GENERIC  GOTO IF IN	IS LIMITED LOOP MOD  NEW NOT  NULL OF OR
  OTHERS OUT  PACKAGE PRAGMA  PRIVATE PROCEDURE  RAISE	RANGE RECORD REM
  RENAMES RETURN REVERSE  SELECT  SEPARATE SUBTYPE  TASK TERMINATE  THEN
  TYPE USE WHEN WHILE WITH XOR

  identifier	numeric_literal     string_literal     character_literal

  & ' ( ) * + , - . / : ;  < = >  '|' => .. **  := /=  >=  <= <<  >>  <>

%start -----------------------------------------------------------------

  compilation

%rules -----------------------------------------------------------------

--Standard initial IDL items

@@  root	     => xd_high_page	: num_val,
@@			xd_user_root	: user_root,
@@			xd_source_list	: Seq Of sourceline,
@@			xd_err_count	: num_val,
@@			spare_1 	: void;
@@
@@  txtrep	     =>;		-- representation of text
@@
@@  num_val	     =>;		-- representation of (small) integer
@@
@@  BOOLEAN::= false | true;
@@
@@  false	     =>;		 -- used for Boolean
@@
@@  true	     =>;
@@
@@  nil 	     =>;		 -- empty list
@@
@@  list	     => xd_head 	: void,       -- list representation
@@			xd_tail 	: void;
@@
@@  sourceline	     => xd_number	: num_val,
@@			xd_error_list	: Seq Of error;
@@
@@  error	     => xd_srcpos	: Source_Position,
@@			xd_text 	: txtrep;
@@
@@  symbol_rep	     => xd_text 	: txtrep,
@@			xd_deflist	: Seq Of DEF_NAME;
@@
@@  hash	     => xd_list 	: Seq Of symbol_rep;
@@
@@ STANDARD_IDL ::=	root | txtrep | num_val | BOOLEAN | nil | list
@@		      | sourceline | error | symbol_rep | hash | void;

-- 2.  Lexical Elements
-- ====================

-- Syntax 2.0
--     has no equivalent in concrete syntax
--

@@  void => ;

-- 2.3 Identifiers, 2.4 Numeric Literals, 2.6 String Literals

-- Syntax 2.3
--     not of interest for Diana
--

@@  DEF_NAME ::=	    SOURCE_NAME | PREDEF_NAME;
@@  DEF_NAME => 	    lx_symrep : symbol_rep;

@@  SOURCE_NAME ::=	    OBJECT_NAME | TYPE_NAME | UNIT_NAME | LABEL_NAME;
@@  SOURCE_NAME =>	    xd_region: SOURCE_NAME;

@@  OBJECT_NAME =>	    sm_obj_type : TYPE_SPEC;

@@  UNIT_NAME =>	    sm_first : DEF_NAME;


-- 2.8	Pragmas
--     These productions do not correspond to productions in the
--     concrete syntax.

-- Syntax 2.8.A
-- pragma ::=
--     pragma identifier [(argument_association {, argument_association})];
--
pragma ::=
      PRAGMA  used_name_id [(argument_association{,argument_association})] ;
						====> $2 pragma

used_name_id  ::=  identifier			====> $0 used_name_id lx_symrep

[(argument_association{,argument_association})] ::=
      empty					====> nil $L general_assoc_s
   |  (  argument_association{,argument_association}  )
						====> $L general_assoc_s

pragma_s ::= pragma {pragma}			====> insert $L pragma_s

[pragma_s] ::= {pragma} 			====> $L pragma_s

@@  pragma =>		    as_used_name_id : used_name_id,
@@			    as_general_assoc_s : general_assoc_s;
++  pragma =>		    lx_srcpos -- ALL_SOURCE
@@				    -- seq of EXP and/or assoc

@@  general_assoc_s =>	    as_list : Seq Of GENERAL_ASSOC;
++  general_assoc_s =>	    lx_srcpos -- ALL_SOURCE


-- Syntax 2.8.B
--  argument_association ::=
--	 [argument_identifier =>] name
--     | [argument_identifier =>] expression
--

argument_association  ::=
      expression
   |  used_name_id => expression		====> exch_1 $2 assoc

-- 3.  Declarations and Types
-- ==========================
-- 3.1	Declarations

-- Syntax 3.1
--  basic_declaration ::=
--	 object_declaration	 | number_declaration
--     | type_declaration	 | subtype_declaration
--     | subprogram_declaration  | package_declaration
--     | task_declaration	 | generic_declaration
--     | exception_declaration	 | generic_instantiation
--     | renaming_declaration	 | deferred_constant_declaration

basic_declaration ::=
      var_declaration	      | number_declaration
    | type_declaration	      | subtype_declaration
    | subprogram_declaration  | package_declaration
    | task_declaration	      | generic_declaration
    | exception_declaration   | generic_instantiation
    | renaming_declaration    | constant_declaration

@@  DECL ::=		    ID_S_DECL | ID_DECL;

@@  ID_DECL ::= 	    type_decl
@@			  | subtype_decl
@@			  | task_decl
@@			  | UNIT_DECL;
@@  ID_DECL =>		    as_source_name : SOURCE_NAME;

@@  ID_S_DECL ::=	    EXP_DECL
@@			  | exception_decl
@@			  | deferred_constant_decl;
@@  ID_S_DECL =>	    as_source_name_s : source_name_s;

@@  EXP_DECL ::=	    OBJECT_DECL
@@			  | number_decl;
@@  EXP_DECL => 	    as_exp : EXP;


-- 3.2	Objects and Named Numbers

-- Syntax 3.2.A
--  object_declaration ::=
--     identifier_list : [constant] subtype_indication [:= expression];
--   | identifier_list : [constant] constrained_array_definition [:= expression

--** Declarations defined such that xxx_id nodes not created until after
--** the definition has been parsed.  Note that '$DEF' inserts the appropriate
--** node at the beginning of the list which is the first son of the node at
--** the top of the semantic stack.

constant_declaration ::=
      identifier  :  constant_definition  ;	====> $DEF constant_id
   |  identifier  ,  constant_declaration	====> $DEF constant_id

constant_definition ::=
       CONSTANT  subtype_indication  :=  expression
						====> exch_1 $N3 constant_decl
    |  CONSTANT  constrained_array_definition  :=  expression
						====> exch_1 $N3 constant_decl
    |  CONSTANT  type_mark			====> $N2 deferred_constant_decl

var_declaration ::=
      identifier  :  var_definition	  ;	====> $DEF variable_id
   |  identifier  ,  var_declaration		====> $DEF variable_id

var_definition ::=
       subtype_indication  [:=expression]
						====> exch_1 $N3 variable_decl
    |  constrained_array_definition  [:=expression]
						====> exch_1 $N3 variable_decl

@@  EXP ::=		    void;

@@  CONSTRAINED_DEF ::=     subtype_indication;

@@  OBJECT_DECL ::=	    constant_decl | variable_decl;
@@  OBJECT_DECL =>	    as_type_def : TYPE_DEF;

++  constant_decl =>	    as_source_name_s -- ID_S_DECL
++			    as_exp -- EXP_DECL
++			    as_type_def -- OBJECT_DECL
++  constant_decl =>	    lx_srcpos -- ALL_SOURCE
@@  constant_decl => ;

++  variable_decl =>	    as_source_name_s -- ID_S_DECL
++			    as_exp -- EXP_DECL
++			    as_type_def -- OBJECT_DECL
++  variable_decl =>	    lx_srcpos -- ALL_SOURCE
@@  variable_decl => ;

@@  OBJECT_NAME ::=	    INIT_OBJECT_NAME;

@@  INIT_OBJECT_NAME ::=    VC_NAME;
@@  INIT_OBJECT_NAME =>     sm_init_exp : EXP;

@@  VC_NAME ::= 	    variable_id | constant_id;
@@  VC_NAME =>		    sm_renames_obj : Boolean,
@@			    sm_address : EXP; -- EXP or void
++  variable_id =>	    lx_srcpos -- ALL_SOURCE
++			    lx_symrep -- DEF_NAME
++  variable_id =>	    sm_obj_type -- OBJECT_NAME
++			    sm_init_exp -- INIT_OBJECT_NAME
++			    sm_renames_obj -- VC_NAME
++			    sm_address -- VC_NAME
++  variable_id =>	    xd_region -- SOURCE_NAME
@@  variable_id =>	    sm_is_shared : Boolean;

++  constant_id =>	    lx_srcpos -- ALL_SOURCE
++			    lx_symrep -- DEF_NAME
++  constant_id =>	    sm_obj_type -- OBJECT_NAME
++			    sm_init_exp -- INIT_OBJECT_NAME
++			    sm_renames_obj -- VC_NAME
++			    sm_address -- VC_NAME
++  constant_id =>	    xd_region -- SOURCE_NAME
@@  constant_id =>	    sm_first : DEF_NAME;


-- Syntax 3.2.B
--  number_declaration ::=
--     identifier_list : constant := universal_static_expression;

number_declaration ::=
      identifier  :  number_definition	  ;	====> $DEF number_id
   |  identifier  ,  number_declaration 	====> $DEF number_id

number_definition ::=
       CONSTANT  :=  expression 		====> $N2 number_decl

++  number_decl =>	    as_source_name_s -- ID_S_DECL
++			    as_exp -- EXP_DECL
++  number_decl =>	    lx_srcpos -- ALL_SOURCE
@@  number_decl => ;

@@  INIT_OBJECT_NAME ::=    number_id;

++  number_id =>	    lx_srcpos -- ALL_SOURCE
++			    lx_symrep -- DEF_NAME
++  number_id =>	    sm_obj_type -- OBJECT_NAME
++			    sm_init_exp -- INIT_OBJECT_NAME
++  number_id =>	    xd_region -- SOURCE_NAME
@@  number_id => ;


-- Syntax 3.2.C
--  identifier_list ::= identifier {, identifier}

--**  Unused syntax, since list is built by means of $DEF's

@@  source_name_s =>	    as_list : Seq Of SOURCE_NAME;
++  source_name_s =>	    lx_srcpos -- ALL_SOURCE

-- 3.3	Types and Subtypes
-- 3.3.1 Type Declarations

-- Syntax 3.3.1.A
--  type_declaration ::= full_type_declaration
--     | incomplete_type_declaration | private_type_declaration
--
--  full_type_declaration ::=
--     type identifier [discriminant_part] is type_definition;

type_declaration ::= full_type_declaration
   |  incomplete_type_declaration | private_type_declaration

full_type_declaration ::=
      TYPE  identifier [discriminant_part]__IS type_definition ;
						====> $V3 type_decl $DEF type_id

++  type_decl =>	    as_source_name -- ID_DECL
@@  type_decl =>	    as_dscrmt_decl_s : dscrmt_decl_s,
@@			    as_type_def : TYPE_DEF;
++  type_decl =>	    lx_srcpos -- ALL_SOURCE

@@  TYPE_NAME ::=	    type_id;
@@  TYPE_NAME =>	    sm_type_spec : TYPE_SPEC;

++  type_id =>		    lx_srcpos -- ALL_SOURCE
++			    lx_symrep -- DEF_NAME
++  type_id =>		    sm_type_spec -- TYPE_NAME
++  type_id =>		    xd_region -- SOURCE_NAME
@@  type_id =>		    sm_first : DEF_NAME;


-- Syntax 3.3.1.B
--  type_definition ::=
--     enumeration_type_definition  | integer_type_definition
--   | real_type_definition	    | array_type_definition
--   | record_type_definition	    | access_type_definition
--   | derived_type_definition

type_definition ::=
     enumeration_type_definition  | integer_type_definition
   | real_type_definition	  | array_type_definition
   | record_type_definition	  | access_type_definition
   | derived_type_definition

@@  TYPE_DEF ::=	    enumeration_def
@@			  | CONSTRAINED_DEF
@@			  | ARR_ACC_DER_DEF
@@			  | record_def;

@@  CONSTRAINED_DEF ::=     integer_def
@@			  | float_def
@@			  | fixed_def;

@@  ARR_ACC_DER_DEF ::=     constrained_array_def
@@			  | unconstrained_array_def
@@			  | access_def
@@			  | derived_def;
@@  ARR_ACC_DER_DEF =>	    as_subtype_indication : subtype_indication;

@@  TYPE_SPEC ::=	    DERIVABLE_SPEC;

@@  DERIVABLE_SPEC ::=	    FULL_TYPE_SPEC | PRIVATE_SPEC;
@@  DERIVABLE_SPEC =>	    xd_source_name: SOURCE_NAME,
@@			    sm_derived : TYPE_SPEC,
@@			    sm_is_anonymous : Boolean;

@@  FULL_TYPE_SPEC ::=	    task_spec | NON_TASK;

@@  NON_TASK ::=	    SCALAR | UNCONSTRAINED | CONSTRAINED;
@@  NON_TASK => 	    sm_base_type : TYPE_SPEC;

@@  SCALAR ::=		    enumeration | integer | REAL;
@@  SCALAR =>		    sm_range : RANGE;
@@  SCALAR =>		    cd_impl_size : Integer;

@@  REAL ::=		    float | fixed;
@@  REAL =>		    sm_accuracy : Value;

@@  UNCONSTRAINED ::=	    UNCONSTRAINED_COMPOSITE | access;
@@  UNCONSTRAINED =>	    sm_size : EXP; -- exp or void
@@  UNCONSTRAINED_COMPOSITE ::=array | record;
@@  UNCONSTRAINED_COMPOSITE =>sm_is_limited : Boolean,
@@			    sm_is_packed : Boolean;

@@  CONSTRAINED ::=	    constrained_array
@@			  | constrained_record
@@			  | constrained_access;
@@  CONSTRAINED =>	    sm_depends_on_dscrmt : Boolean;


-- 3.3.2 Subtype Declarations

-- Syntax 3.3.2.A
--  subtype_declaration ::= subtype identifier is subtype_indication;

subtype_declaration ::=
      SUBTYPE  subtype_id  IS  subtype_indication  ;
						====> $2 subtype_decl

subtype_id ::=	identifier			====> $0 subtype_id lx_symrep

++  subtype_decl =>	    as_source_name -- ID_DECL
@@  subtype_decl =>	    as_subtype_indication : subtype_indication;
++  subtype_decl =>	    lx_srcpos -- ALL_SOURCE

@@  TYPE_NAME ::=	    subtype_id;

++  subtype_id =>	    lx_srcpos -- ALL_SOURCE
++			    lx_symrep -- DEF_NAME
++  subtype_id =>	    sm_type_spec -- TYPE_NAME
++  subtype_id =>	    xd_region -- SOURCE_NAME
@@  subtype_id => ;


-- Syntax 3.3.2.B

--  subtype_indication ::= type_mark [constraint]
--
--  type_mark ::= type_name | subtype_name

subtype_indication ::=
	type_mark  [constraint] 	      ====> exch_1 $2 subtype_indication

type_mark ::= expanded_name

expanded_name ::= used_id
      | expanded_name . used_id 		====> $2 selected

@@  CONSTRAINT ::=	    void;

@@  CONSTRAINED_DEF =>	    as_constraint : CONSTRAINT;

++  subtype_indication =>   as_constraint -- CONSTRAINED_DEF
@@  subtype_indication =>   as_name : NAME;
++  subtype_indication =>   lx_srcpos -- ALL_SOURCE


-- Syntax 3.3.2.C

--  constraint ::=
--	 range_constraint | floating_point_constraint | fixed_point_constraint
--     | index_constraint | discriminant_constraint

constraint ::=
      range_constraint	|  floating_point_constraint  |  fixed_point_constraint
     | index_constraint__|__discriminant_constraint

@@  CONSTRAINT ::=	    DISCRETE_RANGE
@@			  | REAL_CONSTRAINT
@@			  | index_constraint
@@			  | dscrmt_constraint;


-- 3.4	Derived Type Definitions

-- Syntax 3.4
--  derived_type_definition ::= new subtype_indication

derived_type_definition ::= NEW subtype_indication
						====> $1 derived_def

++  derived_def =>	    as_subtype_indication -- ARR_ACC_DER_DEF
++  derived_def =>	    lx_srcpos -- ALL_SOURCE
@@  derived_def =>	    xd_derived_subprog_list: Seq Of SUBPROG_NAME;

-- 3.5	Scalar Types

-- Syntax 3.5
--  range_constraint ::= range range
--
--  range ::= range_attribute
--     | simple_expression .. simple_expression

range_constraint ::= RANGE range

range ::= name
     | simple_expression .. simple_expression	====> $2 range

@@  DISCRETE_RANGE ::=	    RANGE
@@			  | discrete_subtype;

@@  RANGE ::=		    range | range_attribute | void;
@@  RANGE =>		    sm_type_spec : TYPE_SPEC;

@@  range =>		    as_exp1 : EXP,
@@			    as_exp2 : EXP;
++  range =>		    lx_srcpos -- ALL_SOURCE
++  range =>		    sm_type_spec -- RANGE

@@  range_attribute =>	    as_name : NAME,
@@			    as_used_name_id : used_name_id,
@@			    as_exp : EXP; -- EXP or void
++  range_attribute =>	    lx_srcpos -- ALL_SOURCE
++  range_attribute =>	    sm_type_spec -- RANGE

-- 3.5.1  Enumeration Types

-- Syntax 3.5.1.A
--  enumeration_type_definition ::=
--    (enumeration_literal_specification {, enumeration_literal_specification})

enumeration_type_definition ::=
     (	enumeration_literal{,enumeration_literal}  )
				      ====> $L enum_literal_s $1 enumeration_def

@@  enumeration_def =>	    as_enum_literal_s : enum_literal_s;
++  enumeration_def =>	    lx_srcpos -- ALL_SOURCE

@@  enum_literal_s =>	    as_list : Seq Of ENUM_LITERAL;
++  enum_literal_s =>	    lx_srcpos -- ALL_SOURCE

++  enumeration =>	    sm_derived -- DERIVABLE_SPEC
++			    sm_is_anonymous -- DERIVABLE_SPEC
++			    sm_base_type -- NON_TASK
++			    sm_range -- SCALAR
++  enumeration =>	    xd_source_name -- DERIVABLE_SPEC
++			    cd_impl_size -- SCALAR
@@  enumeration =>	    sm_literal_s : enum_literal_s;


-- Syntax 3.5.1.B
--  enumeration_literal_specification ::= enumeration_literal
--
--  enumeration_literal ::= identifier | character_literal

enumeration_literal ::= identifier	       ====> $0 enumeration_id lx_symrep
    | character_literal 			====> $0 character_id lx_symrep

@@  OBJECT_NAME ::=	    ENUM_LITERAL;

@@  ENUM_LITERAL ::=	    enumeration_id | character_id;
@@  ENUM_LITERAL =>	    sm_pos : Integer,
@@			    sm_rep : Integer;

++  enumeration_id =>	    lx_srcpos -- ALL_SOURCE
++			    lx_symrep -- DEF_NAME
++  enumeration_id =>	    sm_obj_type -- OBJECT_NAME
++			    sm_pos -- ENUM_LITERAL
++			    sm_rep -- ENUM_LITERAL
++  enumeration_id =>	    xd_region -- SOURCE_NAME
@@  enumeration_id => ;

++  character_id =>	    lx_srcpos -- ALL_SOURCE
++			    lx_symrep -- DEF_NAME
++  character_id =>	    sm_obj_type -- OBJECT_NAME
++			    sm_pos -- ENUM_LITERAL
++			    sm_rep -- ENUM_LITERAL
++  character_id =>	    xd_region -- SOURCE_NAME
@@  character_id => ;


-- 3.5.4  Integer Types

-- Syntax 3.5.4
--  integer_type_definition ::= range_constraint

integer_type_definition ::= range_constraint	====> $1 integer_def

++  integer_def =>	    as_constraint -- CONSTRAINED_DEF
++  integer_def =>	    lx_srcpos -- ALL_SOURCE
@@  integer_def => ;

++  integer =>		    sm_derived -- DERIVABLE_SPEC
++			    sm_is_anonymous -- DERIVABLE_SPEC
++			    sm_base_type -- NON_TASK
++			    sm_range -- SCALAR
++  integer =>		    xd_source_name -- DERIVABLE_SPEC
++			    cd_impl_size -- SCALAR
@@  integer => ;


-- 3.5.6  Real Types

-- Syntax 3.5.6
--  real_type_definition ::=
--     floating_point_constraint | fixed_point_constraint

real_type_definition ::=
     floating_point_constraint			====> $1 float_def
   | fixed_point_constraint			====> $1 fixed_def

@@  REAL_CONSTRAINT ::=     float_constraint
@@			  | fixed_constraint;
@@  REAL_CONSTRAINT =>	    sm_type_spec : TYPE_SPEC;


-- 3.5.7  Floating Point Types

-- Syntax 3.5.7
--  floating_point_constraint ::=
--     floating_accuracy_definition [range_constraint]
--
--  floating_accuracy_definition ::= digits static_simple_expression

floating_point_constraint ::=
     DIGITS  simple_expression	[range_constraint]
						====> $2 float_constraint

++  float_def =>	    as_constraint -- CONSTRAINED_DEF
++  float_def =>	    lx_srcpos -- ALL_SOURCE
@@  float_def => ;

@@  REAL_CONSTRAINT =>	    as_exp : EXP,
@@			    as_range : RANGE;

++  float_constraint =>     as_exp -- REAL_CONSTRAINT
++			    as_range -- REAL_CONSTRAINT
++  float_constraint =>     lx_srcpos -- ALL_SOURCE
++  float_constraint =>     sm_type_spec -- REAL_CONSTRAINT
@@  float_constraint => ;

++  float =>		    sm_derived -- DERIVABLE_SPEC
++			    sm_is_anonymous -- DERIVABLE_SPEC
++			    sm_base_type -- NON_TASK
++			    sm_range -- SCALAR
++			    sm_accuracy -- REAL
++  float =>		    xd_source_name -- DERIVABLE_SPEC
++			    cd_impl_size -- SCALAR
@@  float => ;



-- 3.5.9  Fixed Point Types

-- Syntax 3.5.9
--  fixed_point_constraint  ::=
--     fixed_accuracy_definition [range_constraint]
--
--  fixed_accuracy_definition ::= delta static_simple_expression

fixed_point_constraint ::=
     DELTA  simple_expression  [range_constraint]
						====> $2 fixed_constraint

++  fixed_def =>	    as_constraint -- CONSTRAINED_DEF
++  fixed_def =>	    lx_srcpos -- ALL_SOURCE
@@  fixed_def => ;

++  fixed_constraint =>     as_exp -- REAL_CONSTRAINT
++			    as_range -- REAL_CONSTRAINT
++  fixed_constraint =>     lx_srcpos -- ALL_SOURCE
++  fixed_constraint =>     sm_type_spec -- REAL_CONSTRAINT
@@  fixed_constraint => ;

++  fixed =>		    sm_derived -- DERIVABLE_SPEC
++			    sm_is_anonymous -- DERIVABLE_SPEC
++			    sm_base_type -- NON_TASK
++			    sm_range -- SCALAR
++			    sm_accuracy -- REAL
++  fixed =>		    xd_source_name -- DERIVABLE_SPEC
++			    cd_impl_size -- SCALAR
@@  fixed =>		    cd_impl_small : Value;



-- 3.6	Array Types

-- Syntax 3.6.A
--  array_type_definition ::=
--     unconstrained_array_definition | constrained_array_definition
--
--  unconstrained_array_definition ::=
--     array(index_subtype_definition {, index_subtype_definition}) of
--		    component_subtype_indication
--
--  constrained_array_definition ::=
--     array index_constraint of component_subtype_indication

array_type_definition ::=
     unconstrained_array_definition | constrained_array_definition

unconstrained_array_definition ::=
     ARRAY  (index_subtype_definition{,index_subtype_definition})  OF
		  subtype_indication	 ====> exch_1 $2 unconstrained_array_def

(index_subtype_definition{,index_subtype_definition}) ::=
      (  index_subtype_definition{,index_subtype_definition}  )
						====> $L index_s

constrained_array_definition ::=
     ARRAY  index_constraint  OF  subtype_indication
					   ====> exch_1 $2 constrained_array_def

++  constrained_array_def =>as_subtype_indication -- ARR_ACC_DER_DEF
@@  constrained_array_def =>as_constraint : CONSTRAINT;
++  constrained_array_def =>lx_srcpos -- ALL_SOURCE

@@  index_constraint =>     as_discrete_range_s : discrete_range_s;
++  index_constraint =>     lx_srcpos -- ALL_SOURCE

@@  discrete_range_s =>     as_list : Seq Of DISCRETE_RANGE;
++  discrete_range_s =>     lx_srcpos -- ALL_SOURCE

++  unconstrained_array_def =>as_subtype_indication -- ARR_ACC_DER_DEF
@@  unconstrained_array_def =>as_index_s : index_s;
++  unconstrained_array_def =>lx_srcpos -- ALL_SOURCE

@@  scalar_s => 	    as_list : Seq Of SCALAR;
++  scalar_s => 	    lx_srcpos -- ALL_SOURCE

++  array =>		    sm_derived -- DERIVABLE_SPEC
++			    sm_is_anonymous -- DERIVABLE_SPEC
++			    sm_base_type -- NON_TASK
++			    sm_size -- UNCONSTRAINED
++			    sm_is_limited -- UNCONSTRAINED_COMPOSITE
++			    sm_is_packed -- UNCONSTRAINED_COMPOSITE
++  array =>		    xd_source_name -- DERIVABLE_SPEC
@@  array =>		    sm_index_s : index_s,
@@			    sm_comp_type : TYPE_SPEC;

++  constrained_array =>    sm_derived -- DERIVABLE_SPEC
++			    sm_is_anonymous -- DERIVABLE_SPEC
++			    sm_base_type -- NON_TASK
++			    sm_depends_on_dscrmt -- CONSTRAINED
++  constrained_array =>    xd_source_name -- DERIVABLE_SPEC
@@  constrained_array =>    sm_index_subtype_s : scalar_s;



-- Syntax 3.6.B
--  index_subtype_definition ::= type_mark range <>

index_subtype_definition ::= type_mark__RANGE__<>

--** name instead of type_mark to avoid LALR conflict

type_mark__RANGE__<> ::= name RANGE <>		====> $1 index

@@  index =>		    as_name : NAME,
@@			    sm_type_spec : TYPE_SPEC;
++  index =>		    lx_srcpos -- ALL_SOURCE

@@  index_s =>		    as_list : Seq Of index;
++  index_s =>		    lx_srcpos -- ALL_SOURCE


-- Syntax 3.6.C
--  index_constraint ::= (discrete_range {, discrete_range})
--
--  discrete_range ::= discrete_subtype_indication | range

index_constraint  ::=  (  discrete_range{,discrete_range}  )
				   ====> $L discrete_range_s $1 index_constraint

--** This definition of index_constraint used only in constrained array
--** definitions.  In subtype indications, the wider class,
--** index_constraint__|__discriminant_constraint is used

discrete_range ::= range
      | name range_constraint
			  ====> exch_1 $2 subtype_indication $1 discrete_subtype

--** The name must be an expanded_name

@@  discrete_subtype =>     as_subtype_indication : subtype_indication;
++  discrete_subtype =>     lx_srcpos -- ALL_SOURCE


-- 3.7	Record Types

-- Syntax 3.7.A
--  record_type_definition ::=
--     record
--	    component_list
--     end record

record_type_definition ::=
     RECORD  component_list  END  RECORD	====> $1 record_def

@@  REP ::=		    void;

@@  record_def =>	    as_comp_list : comp_list;
++  record_def =>	    lx_srcpos -- ALL_SOURCE

++  record =>		    sm_derived -- DERIVABLE_SPEC
++			    sm_is_anonymous -- DERIVABLE_SPEC
++			    sm_base_type -- NON_TASK
++			    sm_size -- UNCONSTRAINED
++			    sm_is_limited -- UNCONSTRAINED_COMPOSITE
++			    sm_is_packed -- UNCONSTRAINED_COMPOSITE
++  record =>		    xd_source_name -- DERIVABLE_SPEC
@@  record =>		    sm_discriminant_s : dscrmt_decl_s,
@@			    sm_comp_list : comp_list,
@@			    sm_representation : REP; -- REP or void

++  constrained_record =>   sm_derived -- DERIVABLE_SPEC
++			    sm_is_anonymous -- DERIVABLE_SPEC
++			    sm_base_type -- NON_TASK
++			    sm_depends_on_dscrmt -- CONSTRAINED
++  constrained_record =>   xd_source_name -- DERIVABLE_SPEC
@@  constrained_record =>   sm_normalized_dscrmt_s : exp_s;


-- Syntax 3.7.B
--  component_list ::=
--	 component_declaration {component_declaration}
--     | {component_declaration} variant_part
--     | null;
--
--  component_declaration ::=
--     identifier_list : component_subtype_definition [:= expression];
--
--  component_subtype_definition ::= subtype_indication

component_list	::=
      component_decl_s			 ====> void nil $L pragma_s $3 comp_list
   |  component_decl_s	variant_part  {pragma}
						====> $L pragma_s $3 comp_list
   |  empty_component_decl_s  variant_part  {pragma}
						====> $L pragma_s $3 comp_list
   |  {pragma} null_comp {pragma}
		 ====> insert cat $L decl_s void nil $L pragma_s $3 comp_list

component_decl_s  ::=
	{pragma} component_declaration {pragma}{component_declaration{pragma}}
						====> insert cat $L decl_s

empty_component_decl_s	::=			====> nil $L decl_s

component_declaration ::=
      identifier  :  component_definition ;	====> $DEF component_id
   |  identifier  ,  component_declaration	====> $DEF component_id

component_definition ::=
       subtype_indication  [:=expression]	====> exch_1 $N3 variable_decl

null_comp ::= NULL ;				====> $0 null_comp_decl

@@  DECL ::=		    null_comp_decl;

++  null_comp_decl =>	    lx_srcpos -- ALL_SOURCE
@@  null_comp_decl => ;
@@		    -- (missing from Intermetrics definition)

@@  INIT_OBJECT_NAME ::=    COMP_NAME;

@@  COMP_NAME ::=	    component_id | discriminant_id;
@@  COMP_NAME =>	    sm_comp_rep : COMP_REP_ELEM;

++  component_id =>	    lx_srcpos -- ALL_SOURCE
++			    lx_symrep -- DEF_NAME
++  component_id =>	    sm_obj_type -- OBJECT_NAME
++			    sm_init_exp -- INIT_OBJECT_NAME
++			    sm_comp_rep -- COMP_NAME
++  component_id =>	    xd_region -- SOURCE_NAME
@@  component_id => ;


-- 3.7.1  Discriminants

-- Syntax 3.7.1
--  discriminant_part ::=
--     (discriminant_specification {; discriminant_specification})
--
--  discriminant_specification ::=
--     identifier_list : type_mark [:= expression]

discriminant_part ::=
     (	discriminant_specification{;discriminant_specification}  )
						====> $L dscrmt_decl_s

[discriminant_part] ::=
	empty					====> nil $L dscrmt_decl_s
      | discriminant_part

discriminant_specification ::=
      identifier  :  discriminant_definition	====> $DEF discriminant_id
   |  identifier  ,  discriminant_specification ====> $DEF discriminant_id

discriminant_definition ::=
       type_mark [:=expression] ====> $N3 dscrmt_decl

@@  ITEM ::=		    DSCRMT_PARAM_DECL;

@@  DSCRMT_PARAM_DECL ::=   dscrmt_decl;
@@  DSCRMT_PARAM_DECL =>    as_source_name_s : source_name_s,
@@			    as_name : NAME,
@@			    as_exp : EXP;

@@  dscrmt_decl_s =>	    as_list : Seq Of dscrmt_decl;
++  dscrmt_decl_s =>	    lx_srcpos -- ALL_SOURCE

++  dscrmt_decl =>	    as_source_name_s -- DSCRMT_PARAM_DECL
++			    as_name -- DSCRMT_PARAM_DECL
++			    as_exp -- DSCRMT_PARAM_DECL
++  dscrmt_decl =>	    lx_srcpos -- ALL_SOURCE
@@  dscrmt_decl => ;

++  discriminant_id =>	    lx_srcpos -- ALL_SOURCE
++			    lx_symrep -- DEF_NAME
++  discriminant_id =>	    sm_obj_type -- OBJECT_NAME
++			    sm_init_exp -- INIT_OBJECT_NAME
++			    sm_comp_rep -- COMP_NAME
++  discriminant_id =>	    xd_region -- SOURCE_NAME
@@  discriminant_id =>	    sm_first : DEF_NAME;


-- 3.7.2  Discriminant Constraints

-- Syntax 3.7.2
--  discriminant_constraint ::=
--     (discriminant_association {, discriminant_association})
--  discriminant_association ::=
--     [discriminant_simple_name {|discriminant_simple_name} =>] expression
--

index_constraint__|__discriminant_constraint ::=
	(  discriminant_association{,discriminant_association}	)
						====> $L general_assoc_s
     |	(  discriminant_association{,discriminant_association}
	   others_association  )
						====> append $L general_assoc_s
     |	(  others_association  )
						====> list $L general_assoc_s

discriminant_association ::=
	expression
     |	simple_expression .. simple_expression	====> $2 range
     |	name range_constraint		      ====> exch_1 $2 subtype_indication
     |	discriminant_choice_s => expression	====> exch_1 $2 named

--** discriminant association includes discrete_range (for index constraint)

discriminant_choice_s ::= discriminant_choice{|discriminant_choice}
						====> $L choice_s

discriminant_choice ::= used_name_id		====> $1 choice_exp

@@  dscrmt_constraint =>    as_general_assoc_s : general_assoc_s;
++  dscrmt_constraint =>    lx_srcpos -- ALL_SOURCE


-- 3.7.3  Variant Parts

-- Syntax 3.7.3.A
--  variant_part ::=
--     case discriminant_simple_name is
--	   variant
--	  {variant}
--     end case;
--
--  variant  ::=
--     when choice {| choice} =>
--	   component_list

variant_pragma ::= pragma			====> $1 variant_pragma

variant_part ::=
    CASE  used_id IS variant_s END CASE ;	====> $2 variant_part

variant_s ::=
      {variant_pragma} {variant} variant	====> append cat $L variant_s
   |  {variant_pragma} {variant} others_variant ====> append cat $L variant_s

--** pragma's between variants picked up in component lists

variant ::= WHEN choice_s => component_list	====> $2 variant

choice_s ::= choice{|choice}			====> $L choice_s

@@  VARIANT_PART ::=	    variant_part | void;

@@  variant_part =>	    as_name : NAME,
@@			    as_variant_s : variant_s;
++  variant_part =>	    lx_srcpos -- ALL_SOURCE

@@  variant_s =>	    as_list : Seq Of VARIANT_ELEM;
++  variant_s =>	    lx_srcpos -- ALL_SOURCE

@@  VARIANT_ELEM ::=	    variant | variant_pragma;

@@  variant =>		    as_choice_s : choice_s,
@@			    as_comp_list : comp_list;
++  variant =>		    lx_srcpos -- ALL_SOURCE

@@  choice_s => 	    as_list : Seq Of CHOICE;
++  choice_s => 	    lx_srcpos -- ALL_SOURCE

@@  comp_list =>	    as_decl_s : decl_s,
@@			    as_variant_part : VARIANT_PART,
@@			    as_pragma_s : pragma_s;
++  comp_list =>	    lx_srcpos -- ALL_SOURCE

@@  variant_pragma =>	    as_pragma : pragma;
++  variant_pragma =>	    lx_srcpos -- ALL_SOURCE


-- Syntax 3.7.3.B
--  choice ::= simple_expression
--     | discrete_range | others | component_simple_name
--

choice ::= simple_expression			====> $1 choice_exp
     |	simple_expression .. simple_expression
						====> $2 range $1 choice_range
     |	name range_constraint
	  ====> exch_1 $2 subtype_indication $1 discrete_subtype $1 choice_range

--** The name must be an expanded_name

others_variant ::= WHEN others_s => component_list
						====> $2 variant

others_s ::= OTHERS			 ====> $0 choice_others list $L choice_s

@@  CHOICE ::=		    choice_exp | choice_range | choice_others;

@@  choice_exp =>	    as_exp : EXP;
++  choice_exp =>	    lx_srcpos -- ALL_SOURCE

@@  choice_range =>	    as_discrete_range : DISCRETE_RANGE;
++  choice_range =>	    lx_srcpos -- ALL_SOURCE

++  choice_others =>	    lx_srcpos -- ALL_SOURCE
@@  choice_others => ;


-- 3.8	Access Types

-- Syntax 3.8
--  access_type_definition ::= access subtype_indication
--

access_type_definition ::= ACCESS subtype_indication
						====> $1 access_def

++  access_def =>	    as_subtype_indication -- ARR_ACC_DER_DEF
++  access_def =>	    lx_srcpos -- ALL_SOURCE
@@  access_def => ;

++  access =>		    sm_derived -- DERIVABLE_SPEC
++			    sm_is_anonymous -- DERIVABLE_SPEC
++			    sm_base_type -- NON_TASK
++			    sm_size -- UNCONSTRAINED
++  access =>		    xd_source_name -- DERIVABLE_SPEC
@@  access =>		    sm_storage_size : EXP, -- EXP or void
@@			    sm_is_controlled : Boolean,
@@			    sm_desig_type : TYPE_SPEC,
@@			    sm_master : ALL_DECL

@@  constrained_access =>   sm_desig_type : TYPE_SPEC;

-- 3.8.1 Incomplete Type Declarations

-- Syntax 3.8.1
--  incomplete_type_declaration ::= type identifier [discriminant_part];
--

incomplete_type_declaration ::=
      TYPE  identifier	[discriminant_part] ;
					   ====> void $V3 type_decl $DEF type_id

@@  TYPE_DEF ::=	    void;

@@  TYPE_SPEC ::=	    incomplete;

@@  incomplete =>	    sm_discriminant_s : dscrmt_decl_s;
@@  incomplete =>	    xd_source_name: SOURCE_NAME,
@@			    xd_full_type_spec: TYPE_SPEC;

@@  TYPE_SPEC ::=	    void;


-- 3.9	Declarative Parts

-- Syntax 3.9.A
--  declarative_part ::=
--     {basic_declarative_item} {later_declarative_item}
--
--  basic_declarative_item ::= basic_declaration
--     | representation_clause | use_clause
--

--** Following Fisher & Charles, a body is the only later_declarative_item
--** which is not also a basic declarative item; it is used as the boundary.

declarative_part  ::=
      {pragma}	{basic_declarative_item{pragma}} ====> cat $L item_s
    | {pragma}	{basic_declarative_item{pragma}}
		body  {pragma}	{later_declarative_item{pragma}}
					    ====> cat insert cat cat $L item_s

basic_declarative_item ::= basic_declaration
     | representation_clause | use_clause

@@  DECL ::=		    REP;
@@  DECL ::=		    USE_PRAGMA;

@@  USE_PRAGMA ::=	    use | pragma;


-- Syntax 3.9.B
--  later_declarative_item ::= body
--     | subprogram_declaration | package_declaration
--     | task_declaration	| generic_declaration
--     | use_clause		| generic_instantiation
--
--  body  ::=  proper_body | body_stub
--
--  proper_body ::= subprogram_body | package_body | task_body

later_declarative_item ::= body
     | subprogram_declaration | package_declaration
     | task_declaration       | generic_declaration
     | use_clause	      | generic_instantiation

body ::= proper_body | body_stub

proper_body ::= subprogram_body | package_body | task_body

@@  ITEM ::=		    DECL | SUBUNIT_BODY;

@@  item_s =>		    as_list : Seq Of ITEM;
++  item_s =>		    lx_srcpos -- ALL_SOURCE

@@  UNIT_DECL ::=	    generic_decl
@@			  | NON_GENERIC_DECL;
@@  UNIT_DECL =>	    as_header : HEADER;

@@  NON_GENERIC_DECL ::=    subprog_entry_decl
@@			  | package_decl;
@@  NON_GENERIC_DECL =>     as_unit_kind : UNIT_KIND;


-- 4.  Names and Expressions
-- =========================
-- 4.1	Names

-- Syntax 4.1.A
--  name ::= simple_name
--     | character_literal    | operator_symbol
--     | indexed_component    | slice
--     | selected_component   | attribute
--
--  simple_name ::= identifier

name ::= used_id
     | used_char	  | used_string
     | indexed_component__|__slice
     | selected_component |  attribute

used_id ::= identifier			====> $0 used_object_id lx_symrep
			-- changed to used_name_id as required

used_char ::= character_literal 	====> $0 used_char lx_symrep

used_string ::= string_literal		====> $0 string_literal lx_symrep

@@  NAME ::=		    DESIGNATOR
@@			  | NAME_EXP;

@@  NAME_EXP ::=	    NAME_VAL
@@			  | indexed
@@			  | slice
@@			  | all;
@@  NAME_EXP => 	    as_name : NAME;
@@  NAME_EXP => 	    sm_exp_type : TYPE_SPEC;

@@  NAME_VAL ::=	    attribute
@@			  | selected;
@@  NAME_VAL => 	    sm_value : Value;

@@  DESIGNATOR ::=	    USED_OBJECT | USED_NAME;
@@  DESIGNATOR =>	    sm_defn : DEF_NAME,
@@			    lx_symrep : symbol_rep;

@@  USED_NAME ::=	    used_op | used_name_id;

++  used_op =>		    lx_srcpos -- ALL_SOURCE
++			    lx_symrep -- DESIGNATOR
++  used_op =>		    sm_defn -- DESIGNATOR
@@  used_op => ;

++  used_name_id =>	    lx_srcpos -- ALL_SOURCE
++			    lx_symrep -- DESIGNATOR
++  used_name_id =>	    sm_defn -- DESIGNATOR
@@  used_name_id => ;

@@  USED_OBJECT ::=	    used_char | used_object_id;
@@  USED_OBJECT =>	    sm_exp_type : TYPE_SPEC,
@@			    sm_value : Value;

++  used_char =>	    lx_srcpos -- ALL_SOURCE
++			    lx_symrep -- DESIGNATOR
++  used_char =>	    sm_defn -- DESIGNATOR
++			    sm_exp_type -- USED_OBJECT
++			    sm_value -- USED_OBJECT
@@  used_char => ;

++  used_object_id =>	    lx_srcpos -- ALL_SOURCE
++			    lx_symrep -- DESIGNATOR
++  used_object_id =>	    sm_defn -- DESIGNATOR
++			    sm_exp_type -- USED_OBJECT
++			    sm_value -- USED_OBJECT
@@  used_object_id => ;



-- Syntax 4.1.B
--  prefix ::= name | function_call

prefix	::=  name

--** name includes function_call

@@  NAME_VAL ::=	    function_call;


-- 4.1.1  Indexed Components

-- Syntax 4.1.1
--  indexed_component ::= prefix(expression {, expression})
--

indexed_component__|__slice  ::=  apply

@@  exp_s =>		    as_list : Seq Of EXP;
++  exp_s =>		    lx_srcpos -- ALL_SOURCE

++  indexed =>		    as_name -- NAME_EXP
@@  indexed =>		    as_exp_s : exp_s;
++  indexed =>		    lx_srcpos -- ALL_SOURCE
++  indexed =>		    sm_exp_type -- NAME_EXP


-- 4.1.2  Slices

-- Syntax 4.1.2
--  slice ::= prefix(discrete_range)

--** slice is parsed as an indexed_component__|__slice

++  slice =>		    as_name -- NAME_EXP
@@  slice =>		    as_discrete_range : DISCRETE_RANGE;
++  slice =>		    lx_srcpos -- ALL_SOURCE
++  slice =>		    sm_exp_type -- NAME_EXP


-- 4.1.3  Selected Components

-- Syntax 4.1.3
--  selected_component ::=  prefix.selector
--
--  selector ::= simple_name
--     | character_literal | operator_symbol | all

selected_component ::=	prefix	.  selector	====> $2 selected
     | prefix  .  ALL				====> $1 all

selector ::= used_id
     | used_char | operator_symbol

++  selected => 	    as_name -- NAME_EXP
@@  selected => 	    as_designator : DESIGNATOR;
++  selected => 	    lx_srcpos -- ALL_SOURCE
++  selected => 	    sm_exp_type -- NAME_EXP
++			    sm_value -- NAME_VAL

++  all =>		    as_name -- NAME_EXP
++  all =>		    lx_srcpos -- ALL_SOURCE
++  all =>		    sm_exp_type -- NAME_EXP
@@  all => ;


-- 4.1.4  Attributes

-- Syntax 4.1.4
--  attribute ::= prefix'attribute_designator
--
--  attribute_designator ::= simple_name [(universal_static_expression)]

attribute  ::=  prefix  '  used_id              ====> void $3 attribute

--** attribute_call parsed as function call

++  attribute =>	    as_name -- NAME_EXP
@@  attribute =>	    as_used_name_id : used_name_id,
@@			    as_exp : EXP;
++  attribute =>	    lx_srcpos -- ALL_SOURCE
++  attribute =>	    sm_exp_type -- NAME_EXP
++			    sm_value -- NAME_VAL


-- 4.2	Literals

-- Refer to 4.4.C for numeric_literal, string_literal,
-- and null_access.
-- Refer to 4.1 for character_literal


-- 4.3	Aggregates

-- Syntax 4.3.A
--  aggregate ::=
--     (component_association {, component_association})

--** Syntax added to not parse ( expression ) as aggregate

aggregate ::=
     ( named_association )
				====> list $L general_assoc_s $1 aggregate
   | ( others_association )
				====> list $L general_assoc_s $1 aggregate
   | ( component_association,{component_association,} component_association )
				====> append $L general_assoc_s $1 aggregate
   | ( component_association,{component_association,} others_association )
				====> append $L general_assoc_s $1 aggregate

@@  aggregate =>	    as_general_assoc_s : general_assoc_s;
++  aggregate =>	    lx_srcpos -- ALL_SOURCE
++  aggregate =>	    sm_exp_type -- EXP_EXP
++			    sm_discrete_range -- AGG_EXP
@@  aggregate =>	    sm_normalized_comp_s : general_assoc_s;



-- Syntax 4.3.B
--  component_association ::=
--     [choice {| choice} => ] expression

component_association ::= expression | named_association

named_association ::= choice_s	=>  expression	====> exch_1 $2 named

others_association ::= others_s  =>  expression ====> exch_1 $2 named

@@  GENERAL_ASSOC ::=	    NAMED_ASSOC | EXP;

@@  NAMED_ASSOC ::=	    named;
@@  NAMED_ASSOC =>	    as_exp : EXP;

++  named =>		    as_exp -- NAMED_ASSOC
@@  named =>		    as_choice_s : choice_s;
++  named =>		    lx_srcpos -- ALL_SOURCE


-- 4.4	Expressions

-- Syntax 4.4.A
--  expression ::=
--	 relation {and relation}  | relation {and then relation}
--     | relation {or relation}   | relation {or else relation}
--     | relation {xor relation}

expression ::= relation 	  | relation_and
       | relation_and_then	  | relation_or
       | relation_or_else	  | relation_xor

relation_and_then ::=
       relation  and_then  relation		====> $3 short_circuit
    |  relation_and_then  and_then  relation	====> $3 short_circuit

and_then ::= AND THEN				====> $0 and_then

relation_or_else ::=
       relation  or_else   relation		====> $3 short_circuit
    |  relation_or_else   or_else   relation	====> $3 short_circuit

or_else  ::= OR ELSE				====> $0 or_else

relation_and ::=
       relation  AND  relation                  ====> infix "AND"
    |  relation_and  AND  relation              ====> infix "AND"

relation_or ::=
       relation  OR  relation                   ====> infix "OR"
    |  relation_or   OR  relation               ====> infix "OR"

relation_xor ::=
       relation  XOR  relation                  ====> infix "XOR"
    |  relation_xor  XOR  relation              ====> infix "XOR"

@@  EXP_VAL ::= 	    short_circuit;

@@  short_circuit =>	    as_exp1 : EXP,
@@			    as_short_circuit_op : SHORT_CIRCUIT_OP,
@@			    as_exp2 : EXP;
++  short_circuit =>	    lx_srcpos -- ALL_SOURCE
++  short_circuit =>	    sm_exp_type -- EXP_EXP
++			    sm_value -- EXP_VAL

@@  SHORT_CIRCUIT_OP ::=    and_then | or_else;

++  and_then => 	    lx_srcpos -- ALL_SOURCE
@@  and_then => ;

++  or_else =>		    lx_srcpos -- ALL_SOURCE
@@  or_else => ;


-- Syntax 4.4.B
--  relation ::=
--	 simple_expression [relational_operator simple_expression]
--     | simple_expression [not] in range
--     | simple_expression [not] in type_mark

relation ::=
      simple_expression
    | simple_expression =  simple_expression    ====> infix "="
    | simple_expression /= simple_expression    ====> infix "/="
    | simple_expression <  simple_expression    ====> infix "<"
    | simple_expression <= simple_expression    ====> infix "<="
    | simple_expression >  simple_expression    ====> infix ">"
    | simple_expression >= simple_expression    ====> infix ">="
    | simple_expression  membership_op	range	====> $3 range_membership

--** range includes type_mark and range_attribute

membership_op ::=
      IN					====> $0 in_op
    | NOT IN					====> $0 not_in

@@  EXP_VAL_EXP ::=	    MEMBERSHIP;

@@  MEMBERSHIP ::=	    range_membership | type_membership;
@@  MEMBERSHIP =>	    as_membership_op : MEMBERSHIP_OP;

++  range_membership =>     as_exp -- EXP_VAL_EXP
++			    as_membership_op -- MEMBERSHIP
@@  range_membership =>     as_range : RANGE;
++  range_membership =>     lx_srcpos -- ALL_SOURCE
++  range_membership =>     sm_exp_type -- EXP_EXP
++			    sm_value -- EXP_VAL

++  type_membership =>	    as_exp -- EXP_VAL_EXP
++			    as_membership_op -- MEMBERSHIP
@@  type_membership =>	    as_name : NAME;
++  type_membership =>	    lx_srcpos -- ALL_SOURCE
++  type_membership =>	    sm_exp_type -- EXP_EXP
++			    sm_value -- EXP_VAL

@@  MEMBERSHIP_OP ::=	    in_op | not_in;

++  in_op =>		    lx_srcpos -- ALL_SOURCE
@@  in_op => ;

++  not_in =>		    lx_srcpos -- ALL_SOURCE
@@  not_in => ;


-- Syntax 4.4.C
--  simple_expression ::=
--     [unary_operator] term {binary_adding_operator term}
--
--  term ::= factor {multiplying_operator factor}
--
--  factor ::= primary [** primary] | abs primary | not primary

simple_expression ::=
	[unary_operator]term
     |  simple_expression  +  term              ====> infix "+"
     |  simple_expression  -  term              ====> infix "-"
     |  simple_expression  &  term              ====> infix "&"

term ::= factor
   | term / factor                              ====> infix "/"
   | term * factor                              ====> infix "*"
   | term MOD factor                            ====> infix "MOD"
   | term REM factor                            ====> infix "REM"

factor ::= primary
     | primary  **  primary                     ====> infix "**"
     | ABS primary                              ====> unary "ABS"
     | NOT primary                              ====> unary "NOT"

[unary_operator]term ::=
	term
     |  +  term                                 ====> unary "+"
     |  -  term                                 ====> unary "-"

-- Syntax 4.4.D
--  primary ::=
--	 numeric_literal | null | aggregate | string_literal | name | allocator
--     | function_call | type_conversion | qualified_expression | (expression)

primary ::=
	numeric_literal 		      ====> $0 numeric_literal lx_numrep
     |	NULL					====> $0 null_access
     |	aggregate  |  name  |  allocator
     |	qualified_expression
     |	(  expression  )			====> $1 parenthesized

--** string_literal, function_call and type_conversion are included in name

@@  EXP ::=		    NAME
@@			  | EXP_EXP;

@@  EXP_EXP ::= 	    EXP_VAL
@@			  | AGG_EXP
@@			  | qualified_allocator
@@			  | subtype_allocator;
@@  EXP_EXP =>		    sm_exp_type : TYPE_SPEC;

@@  EXP_VAL ::= 	    numeric_literal
@@			  | null_access
@@			  | EXP_VAL_EXP;
@@  EXP_VAL =>		    sm_value : Value;

@@  EXP_VAL_EXP ::=	    QUAL_CONV
@@			  | parenthesized;
@@  EXP_VAL_EXP =>	    as_exp : EXP;

@@  AGG_EXP ::= 	    aggregate
@@			  | string_literal;
@@  AGG_EXP =>		    sm_discrete_range : DISCRETE_RANGE;

++  parenthesized =>	    as_exp -- EXP_VAL_EXP
++  parenthesized =>	    lx_srcpos -- ALL_SOURCE
++  parenthesized =>	    sm_exp_type -- EXP_EXP
++			    sm_value -- EXP_VAL
@@  parenthesized => ;

++  numeric_literal =>	    lx_srcpos -- ALL_SOURCE
++  numeric_literal =>	    sm_exp_type -- EXP_EXP
++			    sm_value -- EXP_VAL
@@  numeric_literal =>	    lx_numrep : Number_Rep;

++  string_literal =>	    lx_srcpos -- ALL_SOURCE
++  string_literal =>	    sm_exp_type -- EXP_EXP
++			    sm_discrete_range -- AGG_EXP
@@  string_literal =>	    lx_symrep : symbol_rep;

++  null_access =>	    lx_srcpos -- ALL_SOURCE
++  null_access =>	    sm_exp_type -- EXP_EXP
++			    sm_value -- EXP_VAL
@@  null_access => ;


-- 4.5	Operators and Expression Evaluation

-- Syntax 4.5
--  logical_operator ::= and | or | xor
--
--  relational_operator ::=  = | /= | < | <= | > | >=
--
--  adding_operator ::= + | - | &
--
--  unary_operator ::= + | -
--
--  multiplying_operator ::= * | / | mod | rem
--
--  highest_precedence_operator ::= ** | abs | not


-- 4.6	Type Conversions

-- Syntax 4.6
--  type_conversion ::= type_mark(expression)

--** parsed as name

@@  QUAL_CONV ::=	    conversion
@@			  | qualified;
@@  QUAL_CONV =>	    as_name : NAME;

++  conversion =>	    as_exp -- EXP_VAL_EXP
++			    as_name -- QUAL_CONV
++  conversion =>	    lx_srcpos -- ALL_SOURCE
++  conversion =>	    sm_exp_type -- EXP_EXP
++			    sm_value -- EXP_VAL
@@  conversion => ;


-- 4.7	Qualified Expressions

-- Syntax 4.7
--  qualified_expression ::=
--     type_mark'(expression) | type_mark'aggregate

qualified_expression ::=
        prefix  '  (  expression  )             ====> exch_1 $2 qualified
     |  prefix  '  aggregate                    ====> exch_1 $2 qualified

--** The 'prefix' must be a 'type_mark'

++  qualified =>	    as_exp -- EXP_VAL_EXP
++			    as_name -- QUAL_CONV
++  qualified =>	    lx_srcpos -- ALL_SOURCE
++  qualified =>	    sm_exp_type -- EXP_EXP
++			    sm_value -- EXP_VAL
@@  qualified => ;



-- 4.8	Allocators

-- Syntax 4.8
--  allocator ::=
--     new subtype_indication | new qualified_expression

allocator ::=
     NEW  allocator_subtype_indication		====> $1 subtype_allocator
   | NEW  allocator_qualified_expression	====> $1 qualified_allocator

--** The only allowed forms of constraint in the subtype indication of
--** an allocator are index and discriminant constraints [RM 4.8/4]

allocator_subtype_indication ::=
	type_mark
     |	type_mark  index_constraint__|__discriminant_constraint
					      ====> exch_1 $2 subtype_indication

--** Elsewhere, a qualified_expression begins with prefix to avoid
--** LALR conflict.  Here, type mark can (must) be used.

allocator_qualified_expression ::=
        type_mark  ' ( expression )             ====> exch_1 $2 qualified
     |  type_mark  ' aggregate                  ====> exch_1 $2 qualified

@@  qualified_allocator =>  as_qualified : qualified;
++  qualified_allocator =>  lx_srcpos -- ALL_SOURCE
++  qualified_allocator =>  sm_exp_type -- EXP_EXP

@@  subtype_allocator =>    as_subtype_indication : subtype_indication,
@@			    sm_desig_type : TYPE_SPEC;
++  subtype_allocator =>    lx_srcpos -- ALL_SOURCE
++  subtype_allocator =>    sm_exp_type -- EXP_EXP


-- 5.  Statements
-- ==============
-- 5.1	Simple and Compound Statements - Sequences of Statements

-- Syntax 5.1.A
--  sequence_of_statements ::= statement {statement}

sequence_of_statements	::=
      {stm_pragma} stm_s_tail			====> cat $L stm_s

stm_s_tail  ::=
      statement  {stm_pragma}			====> insert
    | stm_s_tail  statement  {stm_pragma}	====> insert cat

stm_pragma ::= pragma				====> $1 stm_pragma

@@  STM_ELEM ::=	    STM | stm_pragma;

@@  stm_s =>		    as_list : Seq Of STM_ELEM;
++  stm_s =>		    lx_srcpos -- ALL_SOURCE

@@  stm_pragma =>	    as_pragma : pragma;
++  stm_pragma =>	    lx_srcpos -- ALL_SOURCE


-- Syntax 5.1.B
--  statement ::=
--     {label} simple_statement | {label} compound_statement

statement ::=
     simple_statement
   | compound_statement
   | label_s  [pragma_s]  simple_statement		====> $3 labeled
   | label_s  [pragma_s]  compound_statement		====> $3 labeled

@@  STM ::=		    labeled;

@@  labeled =>		    as_source_name_s : source_name_s,
@@			    as_pragma_s : pragma_s,
@@			    as_stm : STM;
++  labeled =>		    lx_srcpos -- ALL_SOURCE


-- Syntax 5.1.C
--  simple_statement ::= null_statement
--     | assignment_statement | procedure_call_statement
--     | exit_statement       | return_statement
--     | goto_statement       | entry_call_statement
--     | delay_statement      | abort_statement
--     | raise_statement      | code_statement

simple_statement ::= null_statement
     | assignment_statement	 |  goto_statement
     | exit_statement		 |  return_statement
     | delay_statement		 |  abort_statement
     | raise_statement		 |  code_statement
     | procedure_call_statement__|__entry_call_statement

procedure_call_statement__|__entry_call_statement ::= procedure_call_statement

--** Semantics required to determine that call is to an entry

@@  STM ::=		    null_stm
@@			  | abort;
@@  STM ::=		    STM_WITH_EXP;

@@  STM_WITH_EXP ::=	    return
@@			  | delay;
@@  STM_WITH_EXP ::=	    STM_WITH_EXP_NAME;
@@  STM_WITH_EXP =>	    as_exp : EXP;

@@  STM_WITH_EXP_NAME ::=   assign
@@			  | exit
@@			  | code;
@@  STM_WITH_EXP_NAME =>    as_name : NAME;

@@  STM ::=		    STM_WITH_NAME;

@@  STM_WITH_NAME ::=	    goto
@@			  | raise;
@@  STM_WITH_NAME ::=	    CALL_STM;

@@  CALL_STM ::=	    entry_call
@@			  | procedure_call;

@@  STM_WITH_NAME =>	    as_name : NAME;


-- Syntax 5.1.D
--  compound_statement ::=
--	 if_statement	      | case_statement
--     | loop_statement       | block_statement
--     | accept_statement     | select_statement

compound_statement ::=
       if_statement	    | case_statement
     | loop_statement	    | block_statement
     | accept_statement     | select_statement

@@  STM ::=		    accept
@@			  | BLOCK_LOOP
@@			  | ENTRY_STM;

@@  STM_WITH_EXP ::=	    case;

@@  STM ::=		    CLAUSES_STM;

@@  CLAUSES_STM ::=	    if
@@			  | selective_wait;
@@  CLAUSES_STM =>	    as_test_clause_elem_s : test_clause_elem_s,
@@			    as_stm_s : stm_s;


-- Syntax 5.1.E
--  label ::= <<label_simple_name>>

label_id ::= identifier 			====> $0 label_id lx_symrep

label  ::=  <<	label_id  >>

label_s  ::=  label{label}			====> $L source_name_s

@@  LABEL_NAME ::=	    label_id;
@@  LABEL_NAME =>	    sm_stm : STM;

++  label_id => 	    lx_srcpos -- ALL_SOURCE
++			    lx_symrep -- DEF_NAME
++  label_id => 	    sm_stm -- LABEL_NAME
++  label_id => 	    xd_region -- SOURCE_NAME
@@  label_id => ;

-- Syntax 5.1.F
--  null_statement ::= null ;

null_statement ::= NULL ;			====> $0 null_stm

++  null_stm => 	    lx_srcpos -- ALL_SOURCE
@@  null_stm => ;


-- 5.2	Assignment Statement

-- Syntax 5.2
--  assignment_statement ::=
--     variable_name := expression;

assignment_statement ::=
      name  :=	 expression ;			====> exch_1 $2 assign

++  assign =>		    as_exp -- STM_WITH_EXP
++			    as_name -- STM_WITH_EXP_NAME
++  assign =>		    lx_srcpos -- ALL_SOURCE
@@  assign => ;


-- 5.3	If Statements

-- Syntax 5.3.A
--  if_statement ::=
--	if condition then
--	    sequence_of_statements
--     {elsif condition then
--	    sequence_of_statements}
--     [else
--	    sequence_of_statements]
--	end if;

if_statement ::=
       if_clause_s END IF ;				====> nil $L stm_s $2 if
     | if_clause_s else_clause END IF ; 		====> $2 if

if_clause ::= IF condition THEN sequence_of_statements	====> $2 cond_clause

elsif_clause ::=
	ELSIF condition THEN sequence_of_statements	====> $2 cond_clause

if_clause_s ::= if_clause{elsif_clause} 	     ====> $L test_clause_elem_s

else_clause ::=  ELSE  sequence_of_statements

condition ::= expression

++  if =>		    as_test_clause_elem_s -- CLAUSES_STM
++			    as_stm_s -- CLAUSES_STM
++  if =>		    lx_srcpos -- ALL_SOURCE
@@  if => ;

@@  TEST_CLAUSE ::=	    cond_clause;
@@  TEST_CLAUSE =>	    as_exp : EXP,
@@			    as_stm_s : stm_s;

++  cond_clause =>	    as_exp -- TEST_CLAUSE
++			    as_stm_s -- TEST_CLAUSE
++  cond_clause =>	    lx_srcpos -- ALL_SOURCE
@@  cond_clause => ;


-- Syntax 5.3.B
--  condition ::= expression


-- 5.4	Case Statements

-- Syntax 5.4
--  case_statement ::=
--     case expression is
--	     case_statement_alternative
--	    {case_statement_alternative}
--     end case;
--
--  case_statement_alternative ::=
--     when choice {| choice } =>
--	    sequence_of_statements}

case_statement ::= CASE expression IS alternative_s END CASE ;
						====> $2 case

alternative_pragma ::= pragma			====> $1 alternative_pragma

alternative_s ::=
     {alternative_pragma} {case_sta_alt} case_sta_alt
					      ====> append cat $L alternative_s
   | {alternative_pragma} {case_sta_alt} case_sta_others
					      ====> append cat $L alternative_s

case_sta_alt ::=
	WHEN  choice_s	=>  sequence_of_statements
						====>  $2 alternative

case_sta_others ::=
	WHEN  others_s	=>  sequence_of_statements
						====>  $2 alternative

@@  ALTERNATIVE_ELEM ::=    alternative | alternative_pragma;

++  case =>		    as_exp -- STM_WITH_EXP
@@  case =>		    as_alternative_s : alternative_s;
++  case =>		    lx_srcpos -- ALL_SOURCE

@@  alternative_s =>	    as_list : Seq Of ALTERNATIVE_ELEM;
++  alternative_s =>	    lx_srcpos -- ALL_SOURCE

@@  alternative =>	    as_choice_s : choice_s,
@@			    as_stm_s : stm_s;
++  alternative =>	    lx_srcpos -- ALL_SOURCE

@@  alternative_pragma =>   as_pragma : pragma;
++  alternative_pragma =>   lx_srcpos -- ALL_SOURCE


-- 5.5	Loop Statements

-- Syntax 5.5.A
--  loop_statement ::=
--     [loop_simple_name:]
--	    [iteration_scheme] loop
--		 sequence_of_statements
--	    end loop [loop_simple_name];

loop_statement ::= loop ;
			    ====> void exch_2 exch_1 $V3 loop $DEF block_loop_id
    | identifier  :  loop  identifier  ;
				    ====> check_name $V3 loop $DEF block_loop_id

loop ::= [iteration_scheme]  LOOP  sequence_of_statements  END	LOOP

@@  BLOCK_LOOP ::=	    loop;
@@  BLOCK_LOOP =>	    as_source_name : SOURCE_NAME;

@@  SOURCE_NAME ::=	    void;

@@  LABEL_NAME ::=	    block_loop_id;

++  block_loop_id =>	    lx_srcpos -- ALL_SOURCE
++			    lx_symrep -- DEF_NAME
++  block_loop_id =>	    sm_stm -- LABEL_NAME
++  block_loop_id =>	    xd_region -- SOURCE_NAME
@@  block_loop_id => ;

@@  ITERATION ::=	    void;

++  loop =>		    as_source_name -- BLOCK_LOOP
@@  loop =>		    as_iteration : ITERATION,
@@			    as_stm_s : stm_s;
++  loop =>		    lx_srcpos -- ALL_SOURCE



-- Syntax 5.5.B
--  iteration_scheme ::=  while condition
--     | for loop_parameter_specification
--
--  loop_parameter_specification ::=
--     identifier in [reverse] discrete_range

iteration_scheme ::=
	WHILE condition 			====> $1 while
     |	FOR  iteration_id  IN  discrete_range	====> $2 for
     |	FOR  iteration_id  IN  REVERSE	discrete_range
						====> $2 reverse

iteration_id ::= identifier			====> $0 iteration_id lx_symrep

@@  ITERATION ::=	    FOR_REV;

@@  FOR_REV ::= 	    for | reverse;
@@  FOR_REV =>		    as_source_name: SOURCE_NAME,
@@			    as_discrete_range: DISCRETE_RANGE;

++  for =>		    as_source_name -- FOR_REV
++			    as_discrete_range -- FOR_REV
++  for =>		    lx_srcpos -- ALL_SOURCE
@@  for => ;

++  reverse =>		    as_source_name -- FOR_REV
++			    as_discrete_range -- FOR_REV
++  reverse =>		    lx_srcpos -- ALL_SOURCE
@@  reverse => ;

@@  OBJECT_NAME ::=	    iteration_id;

++  iteration_id =>	    lx_srcpos -- ALL_SOURCE
++			    lx_symrep -- DEF_NAME
++  iteration_id =>	    sm_obj_type -- OBJECT_NAME
++  iteration_id =>	    xd_region -- SOURCE_NAME
@@  iteration_id => ;

@@  ITERATION ::=	    while;

@@  while =>		    as_exp : EXP;
++  while =>		    lx_srcpos -- ALL_SOURCE



-- 5.6	Block Statements

-- Syntax 5.6
--  block_statement ::=
--     [block_simple_name:]
--	    [declare
--		 declarative_part]
--	    begin
--		 sequence_of_statements
--	    [exception
--		  exception_handler
--		 {exception_handler}]
--	    end [block_simple_name];

block_statement ::= block ;
			       ====> void exch_1 $V2 block $DEF block_loop_id
    | identifier  :  block  identifier ;
				====> check_name $V2 block $DEF block_loop_id

block ::= [DECLARE__declarative_part]  BEGIN  sequence_of_statements
		[EXCEPTION__exception_handler{exception_handler}]  END
						====> $3 block_body

[DECLARE__declarative_part] ::= empty		====> nil $L item_s
     |	DECLARE  declarative_part

[EXCEPTION__exception_handler{exception_handler}]  ::=
	empty					====> nil $L alternative_s
     |	EXCEPTION  alternative_s

@@  BLOCK_LOOP ::=	    block;

++  block =>		    as_source_name -- BLOCK_LOOP
@@  block =>		    as_block_body : block_body;
++  block =>		    lx_srcpos -- ALL_SOURCE

@@  block_body =>	    as_item_s : item_s,
@@			    as_stm_s : stm_s,
@@			    as_alternative_s : alternative_s;
++  block_body =>	    lx_srcpos -- ALL_SOURCE


-- 5.7	Exit Statements

-- Syntax 5.7
--  exit_statement ::=
--     exit [loop_name] [when condition] ;

exit_statement	::=  EXIT  [expanded_name]  [WHEN__condition] ;
						====> exch_1 $2 exit

[WHEN__condition] ::= empty			====> void
     |	WHEN expression

@@  NAME ::=		    void;

++  exit =>		    as_exp -- STM_WITH_EXP
++			    as_name -- STM_WITH_EXP_NAME
++  exit =>		    lx_srcpos -- ALL_SOURCE
@@  exit =>		    sm_stm : STM;



-- 5.8	Return Statements

-- Syntax 5.8
--  return_statement ::= return [expression] ;

return_statement ::= RETURN [expression] ;	====> $1 return


++  return =>		    as_exp -- STM_WITH_EXP
++  return =>		    lx_srcpos -- ALL_SOURCE
@@  return => ;


-- 5.9	Goto Statements

-- Syntax 5.9
--  goto_statement ::= goto label_name;

goto_statement ::= GOTO expanded_name ; 	====> $1 goto

++  goto =>		    as_name -- STM_WITH_NAME
++  goto =>		    lx_srcpos -- ALL_SOURCE
@@  goto => ;


-- 6.  Subprograms
-- ===============
-- 6.1	Subprogram Declarations

-- Syntax 6.1.A
--  subprogram_declaration ::= subprogram_specification;

subprogram_declaration ::= subprogram_specification ;
						====> void $3 subprog_entry_decl

proc_id ::= identifier				====> $0 procedure_id lx_symrep

function_id ::= identifier			====> $0 function_id lx_symrep

def_op ::= string_literal			====> $0 operator_id lx_symrep

++  subprog_entry_decl =>   as_source_name -- ID_DECL
++			    as_header -- UNIT_DECL
++			    as_unit_kind -- NON_GENERIC_DECL
++  subprog_entry_decl =>   lx_srcpos -- ALL_SOURCE
@@  subprog_entry_decl => ;

@@  UNIT_NAME ::=	    NON_TASK_NAME;

@@  NON_TASK_NAME ::=	    SUBPROG_PACK_NAME;
@@  NON_TASK_NAME =>	    sm_spec : HEADER;
@@  NON_TASK_NAME =>	    xd_stub: stub,
@@			    xd_body: SUBUNIT_BODY;

@@  SUBPROG_PACK_NAME ::=   SUBPROG_NAME;
@@  SUBPROG_PACK_NAME =>    sm_unit_desc : UNIT_DESC,
@@			    sm_address : EXP;

@@  SUBPROG_NAME ::=	    procedure_id | function_id | operator_id;
@@  SUBPROG_NAME =>	    sm_is_inline : Boolean,
@@			    sm_interface : PREDEF_NAME;

@@  UNIT_DESC ::=	    UNIT_KIND | BODY
@@			  | implicit_not_eq | derived_subprog;

@@  UNIT_KIND ::=	    void;

++  derived_subprog =>	    lx_srcpos -- ALL_SOURCE
@@  derived_subprog =>	    sm_derivable : SOURCE_NAME;

++  implicit_not_eq =>	    lx_srcpos -- ALL_SOURCE
@@  implicit_not_eq =>	    sm_equal : SOURCE_NAME;

++  procedure_id =>	    lx_srcpos -- ALL_SOURCE
++			    lx_symrep -- DEF_NAME
++  procedure_id =>	    sm_first -- UNIT_NAME
++			    sm_spec -- NON_TASK_NAME
++			    sm_unit_desc -- SUBPROG_PACK_NAME
++			    sm_address -- SUBPROG_PACK_NAME
++			    sm_is_inline -- SUBPROG_NAME
++			    sm_interface -- SUBPROG_NAME
++  procedure_id =>	    xd_region -- SOURCE_NAME
++			    xd_stub -- NON_TASK_NAME
++			    xd_body -- NON_TASK_NAME
@@  procedure_id => ;

++  function_id =>	    lx_srcpos -- ALL_SOURCE
++			    lx_symrep -- DEF_NAME
++  function_id =>	    sm_first -- UNIT_NAME
++			    sm_spec -- NON_TASK_NAME
++			    sm_unit_desc -- SUBPROG_PACK_NAME
++			    sm_address -- SUBPROG_PACK_NAME
++			    sm_is_inline -- SUBPROG_NAME
++			    sm_interface -- SUBPROG_NAME
++  function_id =>	    xd_region -- SOURCE_NAME
++			    xd_stub -- NON_TASK_NAME
++			    xd_body -- NON_TASK_NAME
@@  function_id => ;

++  operator_id =>	    lx_srcpos -- ALL_SOURCE
++			    lx_symrep -- DEF_NAME
++  operator_id =>	    sm_first -- UNIT_NAME
++			    sm_spec -- NON_TASK_NAME
++			    sm_unit_desc -- SUBPROG_PACK_NAME
++			    sm_address -- SUBPROG_PACK_NAME
++			    sm_is_inline -- SUBPROG_NAME
++			    sm_interface -- SUBPROG_NAME
++  operator_id =>	    xd_region -- SOURCE_NAME
++			    xd_stub -- NON_TASK_NAME
++			    xd_body -- NON_TASK_NAME
@@  operator_id =>	    xd_not_equal: operator_id;
@@                                      -- "/=" corresponding to "="

-- Syntax 6.1.B
--  subprogram_specification ::=
--	 procedure identifier [formal_part]
--     | function designator [formal_part] return type_mark
--
--  designator ::= identifier | operator_symbol
--
--  operator_symbol ::= string_literal

subprogram_specification ::=
       PROCEDURE proc_id procedure_header
     | PROCEDURE proc_id nil_procedure_header
     | FUNCTION function_id function_header
     | FUNCTION def_op function_header

procedure_header ::= param_s			====> $1 procedure_spec

nil_procedure_header ::= nil_param_s		====> $1 procedure_spec

[param_s] ::= nil_param_s
     |	param_s

--** nil_param_s is used for generic instantiation

nil_param_s ::=
	empty					====> nil $L param_s

param_s ::=
     ( parameter_specification{;parameter_specification} )
						====> $L param_s

function_header ::= [param_s] RETURN type_mark	====> $2 function_spec

operator_symbol ::= used_string

@@  HEADER ::=		    SUBP_ENTRY_HEADER;

@@  SUBP_ENTRY_HEADER ::=   procedure_spec | function_spec;
@@  SUBP_ENTRY_HEADER =>    as_param_s : param_s;

++  procedure_spec =>	    as_param_s -- SUBP_ENTRY_HEADER
++  procedure_spec =>	    lx_srcpos -- ALL_SOURCE
@@  procedure_spec => ;

++  function_spec =>	    as_param_s -- SUBP_ENTRY_HEADER
@@  function_spec =>	    as_name : NAME;
++  function_spec =>	    lx_srcpos -- ALL_SOURCE


-- Syntax 6.1.C
--  formal_part ::=
--     (parameter_specification {; parameter_specification})
--
--  parameter_specification ::=
--     identifier_list : mode type_mark [:= expression]
--
--  mode  ::= [in] | in out | out

parameter_specification ::=
	in_specification
     |	in_out_specification
     |	out_specification

in_specification ::=
      identifier  :  in_definition		====> $DEF in_id lx_default
   |  identifier  :  IN in_definition		====> $DEF in_id not_lx_default
   |  identifier  ,  in_specification		====> $DEF in_id

in_definition ::=
       subtype_indication  [:=expression]	====> $N3 in

in_out_specification ::=
      identifier  :  IN OUT in_out_definition	====> $DEF in_out_id
   |  identifier  ,  in_out_specification	====> $DEF in_out_id

in_out_definition ::=
       subtype_indication			====> void $N3 in_out

out_specification ::=
      identifier  :  OUT out_definition 	====> $DEF out_id
   |  identifier  ,  out_specification		====> $DEF out_id

out_definition ::=
       subtype_indication			====> void $N3 out

@@  param_s =>		    as_list : Seq Of PARAM;
++  param_s =>		    lx_srcpos -- ALL_SOURCE

@@  DSCRMT_PARAM_DECL ::=   PARAM;

@@  PARAM ::=		    in | out | in_out;

++  in =>		    as_source_name_s -- DSCRMT_PARAM_DECL
++			    as_name -- DSCRMT_PARAM_DECL
++			    as_exp -- DSCRMT_PARAM_DECL
++  in =>		    lx_srcpos -- ALL_SOURCE
@@  in =>		    lx_default : Boolean;

++  in_out =>		    as_source_name_s -- DSCRMT_PARAM_DECL
++			    as_name -- DSCRMT_PARAM_DECL
++			    as_exp -- DSCRMT_PARAM_DECL
++  in_out =>		    lx_srcpos -- ALL_SOURCE
@@  in_out => ;

++  out =>		    as_source_name_s -- DSCRMT_PARAM_DECL
++			    as_name -- DSCRMT_PARAM_DECL
++			    as_exp -- DSCRMT_PARAM_DECL
++  out =>		    lx_srcpos -- ALL_SOURCE
@@  out => ;

@@  INIT_OBJECT_NAME ::=    PARAM_NAME;

@@  PARAM_NAME ::=	    in_id | in_out_id | out_id;
@@  PARAM_NAME =>	    sm_first : DEF_NAME;

++  in_id =>		    lx_srcpos -- ALL_SOURCE
++			    lx_symrep -- DEF_NAME
++  in_id =>		    sm_obj_type -- OBJECT_NAME
++			    sm_init_exp -- INIT_OBJECT_NAME
++			    sm_first -- PARAM_NAME
++  in_id =>		    xd_region -- SOURCE_NAME
@@  in_id => ;

++  in_out_id =>	    lx_srcpos -- ALL_SOURCE
++			    lx_symrep -- DEF_NAME
++  in_out_id =>	    sm_obj_type -- OBJECT_NAME
++			    sm_init_exp -- INIT_OBJECT_NAME
++			    sm_first -- PARAM_NAME
++  in_out_id =>	    xd_region -- SOURCE_NAME
@@  in_out_id => ;

++  out_id =>		    lx_srcpos -- ALL_SOURCE
++			    lx_symrep -- DEF_NAME
++  out_id =>		    sm_obj_type -- OBJECT_NAME
++			    sm_init_exp -- INIT_OBJECT_NAME
++			    sm_first -- PARAM_NAME
++  out_id =>		    xd_region -- SOURCE_NAME
@@  out_id => ;


-- 6.3	Subprogram Bodies

-- Syntax 6.3
--  subprogram_body ::=
--	subprogram_specification is
--	    [declarative_part]
--	begin
--	    sequence_of_statements
--     [exception
--	     exception_handler
--	    {exception_handler}]
--	end [designator];

subprogram_body ::=
       PROCEDURE proc_id procedure_header subprogram_block
						====> exch_1 $3 subprogram_body
     | PROCEDURE proc_id nil_procedure_header subprogram_block
						====> exch_1 $3 subprogram_body
     | FUNCTION function_id function_header subprogram_block
						====> exch_1 $3 subprogram_body
     | FUNCTION def_op function_header subprogram_block
						====> exch_1 $3 subprogram_body

subprogram_block ::=
	IS declarative_part BEGIN sequence_of_statements
	[EXCEPTION__exception_handler{exception_handler}]
	END__[designator] ;			====> $3 block_body

END__[designator] ::= END
     |	END  identifier 			====> check_subp_name
     |	END  string_literal			====> check_subp_name

@@  BODY ::=		    block_body | stub | void;

++  subprogram_body =>	    as_source_name -- SUBUNIT_BODY
++			    as_body -- SUBUNIT_BODY
@@  subprogram_body =>	    as_header : HEADER;
++  subprogram_body =>	    lx_srcpos -- ALL_SOURCE


-- 6.4	Subprogram Calls

-- Syntax 6.4
--  procedure_call_statement ::=
--     procedure_name [actual_parameter_part];
--
--  function_call ::=
--     function_name [actual_parameter_part]
--
--  actual_parameter_part ::=
--     (parameter_association {, parameter_association})
--
--  parameter_association ::=
--     [formal_parameter =>] actual_parameter
--
--  formal_parameter ::= parameter_simple_name
--
--  actual_parameter ::=
--     expression | variable_name | type_mark(variable_name)

procedure_call_statement ::=
	used_id  ;		  ====> nil $L general_assoc_s $2 procedure_call
     |	selected_component  ;	  ====> nil $L general_assoc_s $2 procedure_call
     |	name  general_assoc_s  ;		====> $2 procedure_call

function_call ::= name

apply ::= name	general_assoc_s 		====> $2 function_call

general_assoc_s ::= ( general_assoc{,general_assoc} )
						====> $L general_assoc_s

general_assoc ::=
	argument_association
     |	simple_expression .. simple_expression	====> $2 range
     |	name range_constraint		      ====> exch_1 $2 subtype_indication

@@  CALL_STM => 	    as_general_assoc_s : general_assoc_s;
@@  CALL_STM => 	    sm_normalized_param_s : exp_s;

++  procedure_call =>	    as_name -- STM_WITH_NAME
++			    as_general_assoc_s -- CALL_STM
++  procedure_call =>	    lx_srcpos -- ALL_SOURCE
++  procedure_call =>	    sm_normalized_param_s -- CALL_STM
@@  procedure_call => ;

++  function_call =>	    as_name -- NAME_EXP
@@  function_call =>	    as_general_assoc_s : general_assoc_s;
++  function_call =>	    lx_srcpos -- ALL_SOURCE
++  function_call =>	    sm_exp_type -- NAME_EXP
++			    sm_value -- NAME_VAL
@@  function_call =>	    sm_normalized_param_s : exp_s;
@@  function_call =>	    lx_prefix : Boolean;

@@  NAMED_ASSOC ::=	    assoc;

++  assoc =>		    as_exp -- NAMED_ASSOC
@@  assoc =>		    as_used_name : USED_NAME;
++  assoc =>		    lx_srcpos -- ALL_SOURCE



-- 7.  Packages
-- ============
-- 7.1	Package Structure

-- Syntax 7.1.A
--  package_declaration ::= package_specification;

++  package_decl =>	    as_source_name -- ID_DECL
++			    as_header -- UNIT_DECL
++			    as_unit_kind -- NON_GENERIC_DECL
++  package_decl =>	    lx_srcpos -- ALL_SOURCE
@@  package_decl => ;

@@  SUBPROG_PACK_NAME ::=   package_id;

++  package_id =>	    lx_srcpos -- ALL_SOURCE
++			    lx_symrep -- DEF_NAME
++  package_id =>	    sm_first -- UNIT_NAME
++			    sm_spec -- NON_TASK_NAME
++			    sm_unit_desc -- SUBPROG_PACK_NAME
++			    sm_address -- SUBPROG_PACK_NAME
++  package_id =>	    xd_region -- SOURCE_NAME
++			    xd_stub -- NON_TASK_NAME
++			    xd_body -- NON_TASK_NAME
@@  package_id => ;

--** See 7.1.B


-- Syntax 7.1.B
--  package_specification ::=
--     package identifier is
--	    {basic_declarative_item}
--     [private
--	    {basic_declarative_item}]
--     end [package_simple_name]

package_declaration ::=
     PACKAGE  package_id  package_definition  END__[simple_name] ;
						====> void $3 package_decl

package_id ::= identifier			====> $0 package_id lx_symrep

package_definition ::= IS decl_s [PRIVATE__decl_s]
						====> $2 package_spec
[PRIVATE__decl_s] ::=
	empty					====> nil $L decl_s
      | PRIVATE  decl_s

decl_s ::=
      {pragma}	{basic_declarative_item{pragma}}
						====> cat $L decl_s

END__[simple_name] ::= END
      | END identifier				====> check_name

@@  package_spec =>	    as_decl_s1 : decl_s,
@@			    as_decl_s2 : decl_s;
++  package_spec =>	    lx_srcpos -- ALL_SOURCE
@@  package_spec =>	    xd_body_is_required: Boolean;

@@  decl_s =>		    as_list : Seq Of DECL;
++  decl_s =>		    lx_srcpos -- ALL_SOURCE


-- Syntax 7.1.C
--  package_body ::=
--	package body package_simple_name is
--	    [declarative_part]
--     [begin
--	      sequence_of_statements
--     [exception
--	     exception_handler
--	    {exception_handler}]]
--	end [package_simple_name];

package_body ::=
	PACKAGE BODY package_id package_block
						====> $2 package_body

package_block ::=
	IS declarative_part BEGIN sequence_of_statements
	[EXCEPTION__exception_handler{exception_handler}]
	END__[designator] ;			====> $3 block_body
     |	IS declarative_part
	END__[designator] ;
			   ====> nil $L stm_s nil $L alternative_s $3 block_body

++  package_body =>	    as_source_name -- SUBUNIT_BODY
++			    as_body -- SUBUNIT_BODY
++  package_body =>	    lx_srcpos -- ALL_SOURCE
@@  package_body => ;


-- 7.4	Private Type and Deferred Constant Declarations

-- Syntax 7.4.A
--  private_type_declaration ::=
--     type identifier [discriminant_part] is [limited] private;

private_type_declaration ::=
      TYPE  identifier	[discriminant_part]__IS  LIMITED  PRIVATE  ;
		    ====> $0 l_private_def $V3 type_decl $DEF l_private_type_id
   |  TYPE  identifier	[discriminant_part]__IS  PRIVATE  ;
			====> $0 private_def $V3 type_decl $DEF private_type_id

[discriminant_part]__IS ::=
	IS					====> nil $L dscrmt_decl_s
      | discriminant_part  IS


@@  TYPE_DEF ::=	    private_def | l_private_def;

++  private_def =>	    lx_srcpos -- ALL_SOURCE
@@  private_def => ;

++  l_private_def =>	    lx_srcpos -- ALL_SOURCE
@@  l_private_def => ;

@@  TYPE_NAME ::=	    private_type_id | l_private_type_id;

++  private_type_id =>	    lx_srcpos -- ALL_SOURCE
++			    lx_symrep -- DEF_NAME
++  private_type_id =>	    sm_type_spec -- TYPE_NAME
++  private_type_id =>	    xd_region -- SOURCE_NAME
@@  private_type_id => ;

++  l_private_type_id =>    lx_srcpos -- ALL_SOURCE
++			    lx_symrep -- DEF_NAME
++  l_private_type_id =>    sm_type_spec -- TYPE_NAME
++  l_private_type_id =>    xd_region -- SOURCE_NAME
@@  l_private_type_id => ;

@@  PRIVATE_SPEC ::=	    private | l_private;
@@  PRIVATE_SPEC =>	    sm_discriminant_s : dscrmt_decl_s,
@@			    sm_type_spec : TYPE_SPEC;

++  private =>		    sm_derived -- DERIVABLE_SPEC
++			    sm_is_anonymous -- DERIVABLE_SPEC
++			    sm_discriminant_s -- PRIVATE_SPEC
++			    sm_type_spec -- PRIVATE_SPEC
++  private =>		    xd_source_name -- DERIVABLE_SPEC
@@  private => ;

++  l_private =>	    sm_derived -- DERIVABLE_SPEC
++			    sm_is_anonymous -- DERIVABLE_SPEC
++			    sm_discriminant_s -- PRIVATE_SPEC
++			    sm_type_spec -- PRIVATE_SPEC
++  l_private =>	    xd_source_name -- DERIVABLE_SPEC
@@  l_private => ;


-- Syntax 7.4.B
--  deferred_constant_declaration ::=
--     identifier_list : constant type_mark;

--** See 3.2.A

++  deferred_constant_decl =>as_source_name_s -- ID_S_DECL
@@  deferred_constant_decl =>as_name : NAME;
++  deferred_constant_decl =>lx_srcpos -- ALL_SOURCE


-- 8.  Visibility Rules
-- ====================
-- 8.4	Use Clauses

-- Syntax 8.4
--  use_clause ::= use package_name {, package_name};

use_clause ::= USE  expanded_name{,expanded_name}  ;
						====> $L name_s $1 use

@@  use =>		    as_name_s : name_s;
++  use =>		    lx_srcpos -- ALL_SOURCE



-- 8.5	Renaming Declarations

-- Syntax 8.5
--  renaming_declaration ::=
--	 identifier : type_mark    renames object_name;
--     | identifier : exception    renames exception_name;
--     | package identifier	   renames package_name;
--     | subprogram_specification  renames subprogram_or_entry_name;

renaming_declaration ::=
	identifier : renamed_var_definition ;	====> $DEF variable_id
     |	identifier : renamed_exception_definition ;
						====> $DEF exception_id
     |	PACKAGE package_id renames_unit ;      ====> void exch_1 $3 package_decl
     |	subprogram_specification renames_unit ; ====> $3 subprog_entry_decl

--** var_id will be replaced by const_id if necessary

renamed_var_definition ::= type_mark RENAMES name
					       ====> exch_1 $V3 renames_obj_decl

renamed_exception_definition ::= EXCEPTION RENAMES name
						====> $V2 renames_exc_decl

renames_unit ::= RENAMES name			====> $1 renames_unit

@@  ID_DECL ::= 	    SIMPLE_RENAME_DECL;

@@  SIMPLE_RENAME_DECL ::=  renames_obj_decl
@@			  | renames_exc_decl;
@@  SIMPLE_RENAME_DECL =>   as_name : NAME;

++  renames_obj_decl =>     as_source_name -- ID_DECL
++			    as_name -- SIMPLE_RENAME_DECL
@@  renames_obj_decl =>     as_type_mark_name : NAME;
++  renames_obj_decl =>     lx_srcpos -- ALL_SOURCE

++  renames_exc_decl =>     as_source_name -- ID_DECL
++			    as_name -- SIMPLE_RENAME_DECL
++  renames_exc_decl =>     lx_srcpos -- ALL_SOURCE
@@  renames_exc_decl => ;

@@  UNIT_KIND ::=	    RENAME_INSTANT;

@@  RENAME_INSTANT ::=	    renames_unit;
@@  RENAME_INSTANT =>	    as_name : NAME;

++  renames_unit =>	    as_name -- RENAME_INSTANT
++  renames_unit =>	    lx_srcpos -- ALL_SOURCE
@@  renames_unit => ;


-- 9.  Tasks
-- =========
-- 9.1	Task Specifications and Task Bodies

-- Syntax 9.1.A
--  task_declaration ::= task_specification;
--
--  task_specification ::=
--     task [type] identifier [is
--	    {entry_declaration}
--	    {representation_clause}
--     end [task_simple_name]]

task_declaration ::=
	TASK  TYPE  type_id  task_spec ;	====> $2 task_decl
     |	TASK  variable_id  task_spec  ; 	====> $2 task_decl

task_spec ::=
	empty					====> nil $L decl_s
     |	IS  entry_list	END__[simple_name]

--** ??? Need to check all the END__[...]'s

type_id ::= identifier				====> $0 type_id lx_symrep

variable_id ::= identifier			====> $0 variable_id lx_symrep

entry_list ::= {pragma}  {entry_declaration{pragma}}
			 {representation_clause{pragma}}
						====> cat cat $L decl_s

++  task_decl =>	    as_source_name -- ID_DECL
@@  task_decl =>	    as_decl_s : decl_s;
++  task_decl =>	    lx_srcpos -- ALL_SOURCE

++  task_spec =>	    sm_derived -- DERIVABLE_SPEC
++			    sm_is_anonymous -- DERIVABLE_SPEC
++  task_spec =>	    xd_source_name -- DERIVABLE_SPEC
@@  task_spec =>	    sm_decl_s : decl_s,
@@			    sm_body : BODY,
@@			    sm_address : EXP,
@@			    sm_size : EXP,
@@			    sm_storage_size : EXP;
@@  task_spec =>	    xd_stub: stub,
@@			    xd_body: SUBUNIT_BODY;


-- Syntax 9.1.B
--  task_body ::=
--	task body task_simple_name is
--	    [declarative_part]
--	begin
--	    sequence_of_statements
--     [exception
--	     exception_handler
--	    {exception_handler}]
--	end [task_simple_name];

task_body ::=
	TASK  BODY  task_body_id  subprogram_block
						====> $2 task_body

task_body_id ::= identifier			====> $0 task_body_id lx_symrep

++  task_body =>	    as_source_name -- SUBUNIT_BODY
++			    as_body -- SUBUNIT_BODY
++  task_body =>	    lx_srcpos -- ALL_SOURCE
@@  task_body => ;

@@  UNIT_NAME ::=	    task_body_id;

++  task_body_id =>	    lx_srcpos -- ALL_SOURCE
++			    lx_symrep -- DEF_NAME
++  task_body_id =>	    sm_first -- UNIT_NAME
++  task_body_id =>	    xd_region -- SOURCE_NAME
@@  task_body_id =>	    sm_type_spec : TYPE_SPEC,
@@			    sm_body : BODY;

-- 9.4 Task Dependence - Termination of Tasks

@@  ALL_DECL ::=	    block_master;

++  block_master =>	    lx_srcpos -- ALL_SOURCE
@@  block_master =>	    sm_stm : STM;


-- 9.5	Entries, Entry Calls and Accept Statements

-- Syntax 9.5.A
--  entry_declaration ::=
--     entry identifier [(discrete_range)] [formal_part];

entry_declaration ::=
	ENTRY entry_id entry_header ;		====> void $3 subprog_entry_decl

entry_id ::= identifier 			====> $0 entry_id lx_symrep

entry_header ::= [param_s]			====> void $2 entry
    |  (  discrete_range  )  [param_s]		====> exch_1 $2 entry

@@  SUBP_ENTRY_HEADER ::=   entry;

++  entry =>		    as_param_s -- SUBP_ENTRY_HEADER
@@  entry =>		    as_discrete_range : DISCRETE_RANGE;
++  entry =>		    lx_srcpos -- ALL_SOURCE

@@  SOURCE_NAME ::=	    entry_id;

++  entry_id => 	    lx_srcpos -- ALL_SOURCE
++			    lx_symrep -- DEF_NAME
++  entry_id => 	    xd_region -- SOURCE_NAME
@@  entry_id => 	    sm_spec : HEADER,
@@			    sm_address : EXP;

-- Syntax 9.5.B
--  entry_call_statement ::= entry_name [actual_parameter_part];

entry_call_statement ::=
	used_id  ;		      ====> nil $L general_assoc_s $2 entry_call
     |	selected_component  ;	      ====> nil $L general_assoc_s $2 entry_call
     |	name  general_assoc_s  ;		====> $2 entry_call

		-- entry call parsed as procedure call where context allows
		--   either a procedure call or an entry call


++  entry_call =>	    as_name -- STM_WITH_NAME
++			    as_general_assoc_s -- CALL_STM
++  entry_call =>	    lx_srcpos -- ALL_SOURCE
++  entry_call =>	    sm_normalized_param_s -- CALL_STM
@@  entry_call => ;

-- Syntax 9.5.C
--  accept_statement ::=
--     accept entry_simple_name [(entry_index)] [formal_part] [do
--	    sequence_of_statements
--     end [entry_simple_name]];
--
--  entry_index ::= expression

accept_statement ::=
	ACCEPT accept_name__[param_s]
	[DO__sequence_of_statements__END[entry_simple_name]]  ;
						====> $3 accept

accept_name__[param_s] ::=
	 used_name_id				====> void
      |  used_name_id param_s
      |  used_name_id__(entry_index)  [param_s]

used_name_id__(entry_index) ::=
	 used_name_id  (  expression  )       ====> list $L exp_s $2 indexed

[DO__sequence_of_statements__END[entry_simple_name]] ::=
	empty					====> nil $L stm_s
     |	DO  sequence_of_statements  END__[entry_simple_name]

END__[entry_simple_name]  ::=  END
     |	END  identifier 			====> check_accept_name

@@  accept =>		    as_name : NAME,
@@			    as_param_s : param_s,
@@			    as_stm_s : stm_s;
++  accept =>		    lx_srcpos -- ALL_SOURCE


-- 9.6	Delay Statements, Duration and Time

-- Syntax 9.6
--  delay_statement ::= delay simple_expression;

delay_statement ::= DELAY  simple_expression  ; ====> $1 delay

++  delay =>		    as_exp -- STM_WITH_EXP
++  delay =>		    lx_srcpos -- ALL_SOURCE
@@  delay => ;


-- 9.7	Select Statements

-- Syntax 9.7
--  select_statement ::= selective_wait
--     | conditional_entry_call | timed_entry_call

select_statement ::= selective_wait
     | conditional_entry_call | timed_entry_call


-- 9.7.1  Selective Waits

-- Syntax 9.7.1.A
--  selective_wait ::=
--	select
--	    select_alternative
--     {or
--	    select_alternative}
--     [else
--	    sequence_of_statements]
--	end select;

-- select_alt_pragma ::= pragma 		====> $1 select_alt_pragma
--** -- parsed as stm_pragma; must be changed in test_clause_elem_s

selective_wait ::=
	SELECT	select_clause_s
	[ELSE__sequence_of_statements]
	END  SELECT  ;				====> $2 selective_wait

select_clause_s ::= select_alternative_list	====> $L test_clause_elem_s

select_alternative_list ::=
	select_alternative			====> list
     |	{stm_pragma} when_select_alternative	====> append
     |	select_alternative_list  OR  select_alternative
						====> append
     |	select_alternative_list  OR  {stm_pragma} when_select_alternative
						====> append cat

[ELSE__sequence_of_statements]	::= empty	====> nil $L stm_s
     |	ELSE  sequence_of_statements

++  selective_wait =>	    as_test_clause_elem_s -- CLAUSES_STM
++			    as_stm_s -- CLAUSES_STM
++  selective_wait =>	    lx_srcpos -- ALL_SOURCE
@@  selective_wait => ;


-- Syntax 9.7.1.B
--  selective_alternative ::=
--     [when condition =>]
--	    selective_wait_alternative
--
--  selective_wait_alternative ::= accept_alternative
--     | delay_alternative | terminate_alternative
--
--  accept_alternative ::= accept_statement [sequence_of_statements]
--
--  delay_alternative ::= delay_statement  [sequence_of_statements]
--
--  terminate_alternative ::= terminate;

when_select_alternative ::=
     WHEN  expression  =>  selective_wait_alternative
						====> $2 select_alternative
select_alternative ::=
   | selective_wait_alternative 		====> $V2 select_alternative

selective_wait_alternative ::= accept_alternative
     | delay_alternative | terminate_alternative

accept_alternative ::= accept_statement[sequence_of_statements]

delay_alternative ::= delay_statement[sequence_of_statements]

terminate_alternative ::= {stm_pragma} terminate {stm_pragma}
						====> insert cat $L stm_s

terminate ::= TERMINATE  ;			====> $0 terminate

accept_statement[sequence_of_statements] ::=
	{stm_pragma} accept_statement {stm_pragma} stm_s_tail
						====> cat insert cat $L stm_s
     |	{stm_pragma} accept_statement		====> append $L stm_s

delay_statement[sequence_of_statements] ::=
	{stm_pragma} delay_statement {stm_pragma} stm_s_tail
						====> cat insert cat $L stm_s
     |	{stm_pragma} delay_statement		====> append $L stm_s

@@  TEST_CLAUSE_ELEM ::=    TEST_CLAUSE | select_alt_pragma;

@@  TEST_CLAUSE ::=	    select_alternative;

@@  test_clause_elem_s =>   as_list : Seq Of TEST_CLAUSE_ELEM;
++  test_clause_elem_s =>   lx_srcpos -- ALL_SOURCE

++  select_alternative =>   as_exp -- TEST_CLAUSE
++			    as_stm_s -- TEST_CLAUSE
++  select_alternative =>   lx_srcpos -- ALL_SOURCE
@@  select_alternative => ;

@@  select_alt_pragma =>    as_pragma : pragma;
++  select_alt_pragma =>    lx_srcpos -- ALL_SOURCE

@@  STM ::=		    terminate;

++  terminate =>	    lx_srcpos -- ALL_SOURCE
@@  terminate => ;


-- 9.7.2  Conditional Entry Calls

-- Syntax 9.7.2
--  conditional_entry_call ::=
--     select
--	     entry_call_statement
--	    [sequence_of_statements]
--     else
--	    sequence_of_statements
--     end select;

conditional_entry_call ::=
	SELECT entry_call_statement[sequence_of_statements]
	ELSE sequence_of_statements END SELECT ;
						====> $2 cond_entry

entry_call_statement[sequence_of_statements] ::=
	{stm_pragma} entry_call_statement {stm_pragma} stm_s_tail
						====> cat insert cat $L stm_s
     |	{stm_pragma} entry_call_statement	====> append $L stm_s

@@  ENTRY_STM ::=	    cond_entry | timed_entry;
@@  ENTRY_STM =>	    as_stm_s1 : stm_s,
@@			    as_stm_s2 : stm_s;

++  cond_entry =>	    as_stm_s1 -- ENTRY_STM
++			    as_stm_s2 -- ENTRY_STM
++  cond_entry =>	    lx_srcpos -- ALL_SOURCE
@@  cond_entry => ;


-- 9.7.3  Timed Entry Calls

-- Syntax 9.7.3
--  timed_entry_call ::=
--     select
--	     entry_call_statement
--	    [sequence_of_statements]
--     or
--	     delay_alternative
--     end select;

timed_entry_call ::=
	SELECT entry_call_statement[sequence_of_statements]
	OR delay_alternative END SELECT ;	====> $2 timed_entry

++  timed_entry =>	    as_stm_s1 -- ENTRY_STM
++			    as_stm_s2 -- ENTRY_STM
++  timed_entry =>	    lx_srcpos -- ALL_SOURCE
@@  timed_entry => ;


-- 9.10  Abort Statements

-- Syntax 9.10
--  abort_statement ::= abort task_name {, task_name};

abort_statement ::= ABORT name_s ;		====> $1 abort

name_s ::= name{,name}				====> $L name_s

@@  name_s =>		    as_list : Seq Of NAME;
++  name_s =>		    lx_srcpos -- ALL_SOURCE

@@  abort =>		    as_name_s : name_s;
++  abort =>		    lx_srcpos -- ALL_SOURCE


-- 10.	Program Structure and Compilation Issues
-- =============================================
-- 10.1  Compilation Units - Library Units

-- Syntax 10.1.A
--  compilation ::= {compilation_unit}

compilation ::=
	pragma_only_unit {compilation_unit}
				   ====> insert $L compltn_unit_s $1 compilation
      | {compilation_unit}		  ====> $L compltn_unit_s $1 compilation

pragma_only_unit ::= null_context pragma_s	====> $3 compilation_unit

null_context ::= empty				====> nil $L context_elem_s void

--** pragma_only_unit records pragmas at beginning of compilation
--** pragmas at end of compilation_unit are parsed as part of unit

@@  compilation =>	    as_compltn_unit_s : compltn_unit_s;
++  compilation =>	    lx_srcpos -- ALL_SOURCE

@@  compltn_unit_s =>	    as_list : Seq Of compilation_unit;
++  compltn_unit_s =>	    lx_srcpos -- ALL_SOURCE


-- Syntax 10.1.B
--  compilation_unit ::=
--     context_clause library_unit | context_clause secondary_unit
--
--  library_unit ::=
--	 subprogram_declaration| package_declaration
--     | generic_declaration   | generic_instantiation
--     | subprogram_body
--
--  secondary_unit ::= library_unit_body | subunit
--
--  library_unit_body ::= subprogram_body | package_body

compilation_unit ::=
	context_clause library_unit [pragma_s]	====> $3 compilation_unit
      | context_clause secondary_unit [pragma_s]
						====> $3 compilation_unit

library_unit ::=
       subprogram_declaration | package_declaration
     | generic_declaration    | generic_instantiation
     | subprogram_body

secondary_unit ::= library_unit_body | subunit

library_unit_body ::= subprogram_body__|__package_body

subprogram_body__|__package_body ::= package_body

--** subprogram_body is already a library unit


-- Context Clauses - With Clauses

@@  ALL_DECL ::=	    void;

@@  pragma_s => 	    as_list : Seq Of pragma;
++  pragma_s => 	    lx_srcpos -- ALL_SOURCE

@@  compilation_unit =>     as_context_elem_s : context_elem_s,
@@			    as_all_decl : ALL_DECL,
@@			    as_pragma_s : pragma_s;
++  compilation_unit =>     lx_srcpos -- ALL_SOURCE
@@  compilation_unit =>     xd_timestamp: Integer,
@@			    xd_with_list: Seq Of trans_with,
@@			    xd_nbr_pages: Integer,
@@			    xd_parent: compilation_unit,
@@			    xd_lib_name: symbol_rep;

@@  CONTEXT_ELEM ::=	    context_pragma;

@@  context_pragma =>	    as_pragma : pragma;
++  context_pragma =>	    lx_srcpos -- ALL_SOURCE
@@		-- context_pragma is never used
@@		-- pragmas are included in the use_pragma_s

-- Syntax 10.1.1.A
--  context_clause ::= {with_clause {use_clause}}

-- context_pragma ::= pragma			====> $1 context_pragma

context_clause ::= {with_clause}		====> $L context_elem_s

@@  context_elem_s =>	    as_list : Seq Of CONTEXT_ELEM;
++  context_elem_s =>	    lx_srcpos -- ALL_SOURCE


-- Syntax 10.1.1.B
--  with_clause ::= with unit_simple_name {, unit_simple_name};

with_clause ::= WITH  name_s  ;  use_pragma_s	====> $2 with

use_pragma_s ::=  {pragma}  {use_clause{pragma}}
						====> cat $L use_pragma_s

@@  CONTEXT_ELEM ::=	    with;

@@  with =>		    as_name_s : name_s,
@@			    as_use_pragma_s : use_pragma_s;
++  with =>		    lx_srcpos -- ALL_SOURCE

@@  use_pragma_s =>	    as_list : Seq Of USE_PRAGMA;
++  use_pragma_s =>	    lx_srcpos -- ALL_SOURCE


-- 10.2  Subunits of Compilation Units

-- Syntax 10.2.A
--  subunit ::=
--     separate (parent_unit_name) proper_body

subunit ::=
	SEPARATE  (  expanded_name  )  proper_body
						====> $2 subunit

@@  subunit =>		    as_name : NAME,
@@			    as_subunit_body : SUBUNIT_BODY;
++  subunit =>		    lx_srcpos -- ALL_SOURCE

@@  SUBUNIT_BODY ::=	    subprogram_body | package_body | task_body;
@@  SUBUNIT_BODY =>	    as_source_name : SOURCE_NAME,
@@			    as_body : BODY;



-- Syntax 10.2.B
--  body_stub ::=
--	 subprogram_specification is separate;
--     | package body package_simple_name is separate;
--     | task body task_simple_name is separate;

body_stub ::=
	PROCEDURE proc_id procedure_header IS__SEPARATE  ;
						====> exch_1 $3 subprogram_body
      | PROCEDURE proc_id nil_procedure_header IS__SEPARATE  ;
						====> exch_1 $3 subprogram_body
      | FUNCTION function_id function_header IS__SEPARATE  ;
						====> exch_1 $3 subprogram_body
      | PACKAGE  BODY  package_id IS__SEPARATE	;
						====> $2 package_body
      | TASK  BODY  task_body_id  IS__SEPARATE	;
						====> $2 task_body

IS__SEPARATE ::= IS SEPARATE			====> $0 stub

++  stub =>		    lx_srcpos -- ALL_SOURCE
@@  stub => ;


-- 11.	Exceptions
-- ===============
-- 11.1  Exception Declarations

-- Syntax 11.1
--  exception_declaration ::= identifier_list : exception;

exception_declaration ::=
	identifier  :  exception_definition  ;	====> $DEF exception_id
      | identifier  ,  exception_declaration	====> $DEF exception_id

exception_definition ::=  EXCEPTION
				    ====> nil $L source_name_s $1 exception_decl

++  exception_decl =>	    as_source_name_s -- ID_S_DECL
++  exception_decl =>	    lx_srcpos -- ALL_SOURCE
@@  exception_decl => ;

@@  SOURCE_NAME ::=	    exception_id;

++  exception_id =>	    lx_srcpos -- ALL_SOURCE
++			    lx_symrep -- DEF_NAME
++  exception_id =>	    xd_region -- SOURCE_NAME
@@  exception_id =>	    sm_renames_exc : NAME;


-- 11.2  Exception Handlers

-- Syntax 11.2
--  exception_handler ::=
--     when exception_choice {| exception_choice} =>
--	    sequence_of_statements
--
--  exception_choice ::= exception_name | others

--** Parsed as case statement alternative


-- 11.3  Raise Statements

-- Syntax 11.3
--  raise_statement ::= raise [exception_name];

raise_statement ::= RAISE  [expanded_name]  ;	====> $1 raise

++  raise =>		    as_name -- STM_WITH_NAME
++  raise =>		    lx_srcpos -- ALL_SOURCE
@@  raise => ;


-- 12.	Generic Program Units
-- ==========================
-- 12.1  Generic Declarations

-- Syntax 12.1.A
--  generic_declaration ::= generic_specification;
--
--  generic_specification ::=
--	 generic_formal_part subprogram_specification
--     | generic_formal_part package_specification

generic_declaration ::= generic_specification ;

generic_specification ::=
       generic_formal_part FUNCTION generic_id function_header
					     ====> exch_1 exch_2 $3 generic_decl
     | generic_formal_part PROCEDURE generic_id procedure_header
					     ====> exch_1 exch_2 $3 generic_decl
     | generic_formal_part PROCEDURE generic_id nil_procedure_header
					     ====> exch_1 exch_2 $3 generic_decl
     | generic_formal_part  PACKAGE  generic_id
       package_definition  END__[simple_name]
					     ====> exch_1 exch_2 $3 generic_decl

generic_id ::= identifier			====> $0 generic_id lx_symrep

@@  HEADER ::=		    package_spec;

++  generic_decl =>	    as_source_name -- ID_DECL
++			    as_header -- UNIT_DECL
@@  generic_decl =>	    as_item_s : item_s;
++  generic_decl =>	    lx_srcpos -- ALL_SOURCE

@@  NON_TASK_NAME ::=	    generic_id;

++  generic_id =>	    lx_srcpos -- ALL_SOURCE
++			    lx_symrep -- DEF_NAME
++  generic_id =>	    sm_first -- UNIT_NAME
++			    sm_spec -- NON_TASK_NAME
++  generic_id =>	    xd_region -- SOURCE_NAME
++			    xd_stub -- NON_TASK_NAME
++			    xd_body -- NON_TASK_NAME
@@  generic_id =>	    sm_generic_param_s : item_s,
@@			    sm_body : BODY,
@@			    sm_is_inline : Boolean;


-- Syntax 12.1.B
--  generic_formal_part ::= generic {generic_parameter_declaration}

generic_formal_part ::=
		 GENERIC {pragma} {generic_parameter_declaration{pragma}}
						====> cat $L item_s


-- Syntax 12.1.C
--  generic_parameter_declaration ::=
--	 identifier_list : [in [out]] type_mark [:= expression];
--     | type identifier is generic_type_definition;
--     | private_type_declaration
--     | with subprogram_specification [is name];
--     | with subprogram_specification [is <>];

generic_parameter_declaration ::=
	in_specification  ;
      | in_out_specification  ;
      | TYPE identifier  empty_discriminant_part__IS  generic_type_definition  ;
						====> $V3 type_decl $DEF type_id
      | private_type_declaration
      | WITH subprogram_specification formal_subprogram_def  ;
						====> $3 subprog_entry_decl

empty_discriminant_part__IS ::=
	IS					====> nil $L dscrmt_decl_s

formal_subprogram_def ::=
	empty					====> $0 no_default
      | IS <>					====> $0 box_default
      | IS name 				====> $1 name_default

@@  UNIT_KIND ::=	    GENERIC_PARAM;

@@  GENERIC_PARAM ::=	    name_default
@@			  | box_default
@@			  | no_default;

@@  name_default =>	    as_name : NAME;
++  name_default =>	    lx_srcpos -- ALL_SOURCE

++  box_default =>	    lx_srcpos -- ALL_SOURCE
@@  box_default => ;

++  no_default =>	    lx_srcpos -- ALL_SOURCE
@@  no_default => ;


-- Syntax 12.1.D
--  generic_type_definition ::=
--	 (<>) | range <> | digits <> | delta <>
--     | array_type_definition | access_type_definition

generic_type_definition ::=
	(  <>  )				====> $0 formal_dscrt_def
     |	RANGE  <>				====> $0 formal_integer_def
     |	DIGITS	<>				====> $0 formal_float_def
     |	DELTA  <>				====> $0 formal_fixed_def
     |	array_type_definition
     |	access_type_definition

@@  TYPE_DEF ::=	    formal_dscrt_def
@@			  | formal_integer_def
@@			  | formal_fixed_def
@@			  | formal_float_def;

++  formal_dscrt_def =>     lx_srcpos -- ALL_SOURCE
@@  formal_dscrt_def => ;

++  formal_fixed_def =>     lx_srcpos -- ALL_SOURCE
@@  formal_fixed_def => ;

++  formal_float_def =>     lx_srcpos -- ALL_SOURCE
@@  formal_float_def => ;

++  formal_integer_def =>   lx_srcpos -- ALL_SOURCE
@@  formal_integer_def => ;


-- 12.3  Generic Instantiation

-- Syntax 12.3.A
--  generic_instantiation ::=
--	 package identifier is
--	      new generic_package_name [generic_actual_part];
--     | procedure identifier is
--	      new generic_procedure_name [generic_actual_part];
--     | function identifier is
--	      new generic_function_name [generic_actual_part];
--
--  generic_actual_part ::=
--     (generic_association {, generic_association})

generic_instantiation ::=
	PACKAGE package_id instantiation       ====> void exch_1 $3 package_decl
     |	PROCEDURE proc_id nil_procedure_header instantiation
						====> $3 subprog_entry_decl
     |	FUNCTION function_id generic_function_header instantiation
						====> $3 subprog_entry_decl
     |	FUNCTION def_op generic_function_header instantiation
						====> $3 subprog_entry_decl

generic_function_header ::= nil_param_s 	====> void $2 function_spec

instantiation ::= IS NEW expanded_name generic_assoc_s ;
						====> $2 instantiation

generic_assoc_s ::= empty			====> nil $L general_assoc_s
      | (  generic_association{,generic_association}  )
						====> $L general_assoc_s

@@  RENAME_INSTANT ::=	    instantiation;

++  instantiation =>	    as_name -- RENAME_INSTANT
@@  instantiation =>	    as_general_assoc_s : general_assoc_s;
++  instantiation =>	    lx_srcpos -- ALL_SOURCE
@@  instantiation =>	    sm_decl_s : decl_s;


-- Syntax 12.3.B
--  generic_association ::=
--     [generic_formal_parameter =>] generic_actual_parameter
--
--  generic_formal_parameter ::= parameter_simple_name | operator_symbol

generic_association ::=
	generic_actual_parameter
     |	used_id  =>  generic_actual_parameter	====> exch_1 $2 assoc
     |	used_string  =>  generic_actual_parameter
						====> exch_1 $2 assoc


-- Syntax 12.3.C
--  generic_actual_parameter ::= expression | variable_name
--     | subprogram_name | entry_name | type_mark

generic_actual_parameter ::= expression


-- 13. Representation Clauses and
-- =====================================
-- Implementation Dependent Features
-- =================================
-- 13.1  Representation Clauses

-- Syntax 13.1
--  representation_clause ::=
--	 type_representation_clause | address_clause
--
--  type_representation_clause ::= length_clause
--     | enumeration_representation_clause | record_representation_clause

representation_clause ::=
       type_representation_clause | address_clause

type_representation_clause ::= length_clause
     | enumeration_representation_clause | record_representation_clause

@@  REP ::=		    NAMED_REP | record_rep;
@@  REP =>		    as_name : NAME;

@@  NAMED_REP =>	    as_exp : EXP;


-- 13.2 Length Clause
-- 13.3 Enumeration Representation Clauses

-- Syntax 13.2
--  length_clause ::= for attribute use simple_expression;

length_clause ::= FOR attribute USE simple_expression ;
						====> $2 length_enum_rep

-- Syntax 13.3
--  enumeration_representation_clause ::=
--	 for type_simple_name use aggregate;

enumeration_representation_clause ::=
	FOR used_id USE aggregate ;		====> $2 length_enum_rep

@@  NAMED_REP ::=	    length_enum_rep;

++  length_enum_rep =>	    as_name -- REP
++			    as_exp -- NAMED_REP
++  length_enum_rep =>	    lx_srcpos -- ALL_SOURCE
@@  length_enum_rep => ;


-- 13.4  Record Representation Clauses

-- Syntax 13.4.A
--  record_representation_clause ::=
--     for type_simple_name use
--	    record [alignment_clause]
--		 {component_clause}
--	    end record;
--
--  alignment_clause ::= at mod static_simple_expression;

record_representation_clause ::=
	FOR used_id USE RECORD null_alignment comp_rep_s END RECORD ;
						====> $3 record_rep
     |	FOR used_id USE RECORD alignment
	{comp_rep_pragma}comp_rep_s END RECORD ;
						====> $3 record_rep

--** Note two definitions to deal with extra {pragma}
--** Leading {pragma} always included in alignment clause even if null

null_alignment ::= [pragma_s]			====> void $2 alignment

alignment ::=
	[pragma_s] AT MOD simple_expression ;	====> $2 alignment

@@  ALIGNMENT_CLAUSE ::=    alignment | void;

@@  alignment =>	    as_pragma_s : pragma_s,
@@			    as_exp : EXP;
++  alignment =>	    lx_srcpos -- ALL_SOURCE

++  record_rep =>	    as_name -- REP
@@  record_rep =>	    as_alignment_clause : ALIGNMENT_CLAUSE,
@@			    as_comp_rep_s : comp_rep_s;
++  record_rep =>	    lx_srcpos -- ALL_SOURCE


-- Syntax 13.4.B
--  component_clause ::=
--     component_simple_name at static_simple_expression range static_range;

comp_rep_pragma ::= pragma			====> $1 comp_rep_pragma

{comp_rep_pragma}comp_rep_s ::=
	{comp_rep_pragma} {component_clause{comp_rep_pragma}}
						====> cat $L comp_rep_s

comp_rep_s ::= {component_clause{comp_rep_pragma}} ====> $L comp_rep_s

component_clause ::=
	used_id  AT  simple_expression RANGE range ;
						====> $3 comp_rep

@@  COMP_REP_ELEM ::=	    comp_rep | void;
@@  COMP_REP_ELEM ::=	    comp_rep_pragma;

@@  comp_rep_s =>	    as_list : Seq Of COMP_REP_ELEM;
++  comp_rep_s =>	    lx_srcpos -- ALL_SOURCE

@@  comp_rep => 	    as_name : NAME,
@@			    as_exp : EXP,
@@			    as_range : RANGE;
++  comp_rep => 	    lx_srcpos -- ALL_SOURCE

@@  comp_rep_pragma =>	    as_pragma : pragma;
++  comp_rep_pragma =>	    lx_srcpos -- ALL_SOURCE


-- 13.5  Address Clauses

-- Syntax 13.5
--  address_clause ::= for simple_name use at simple_expression;

address_clause ::=
	FOR used_id USE AT simple_expression ;
						====> $2 address

@@  NAMED_REP ::=	    address;

++  address =>		    as_name -- REP
++			    as_exp -- NAMED_REP
++  address =>		    lx_srcpos -- ALL_SOURCE
@@  address => ;



-- 13.8  Machine Code Insertions

-- Syntax 13.8
--  code_statement ::= type_mark'record_aggregate;

code_statement ::= prefix  '  aggregate  ;      ====> exch_1 $2 code

--** The 'prefix' must be a 'type_mark'

++  code =>		    as_exp -- STM_WITH_EXP
++			    as_name -- STM_WITH_EXP_NAME
++  code =>		    lx_srcpos -- ALL_SOURCE
@@  code => ;


-- 14.0 Input-Output
-- =================
-- I/O procedure calls are not specially handled. They are
-- represented by procedure or function calls (see 6.4).

-- Predefined Diana Environment
-- ============================
--
-- see Appendix   of this manual
--

@@  PREDEF_NAME ::=	    attribute_id
@@			  | pragma_id
@@			  | argument_id
@@			  | bltn_operator_id
@@			  | void;

++  attribute_id =>	    lx_srcpos -- ALL_SOURCE
++			    lx_symrep -- DEF_NAME
@@  attribute_id =>         xd_pos: Integer; -- Predefined_Attributes'POS

@@  TYPE_SPEC ::=	   universal_integer | universal_fixed | universal_real;

@@  universal_integer => ;

@@  universal_fixed => ;

@@  universal_real => ;

++  argument_id =>	    lx_srcpos -- ALL_SOURCE
++			    lx_symrep -- DEF_NAME
@@  argument_id =>          xd_pos: Integer; -- 'POS in appropriate enum type

++  bltn_operator_id =>     lx_srcpos -- ALL_SOURCE
++			    lx_symrep -- DEF_NAME
@@  bltn_operator_id =>     sm_operator : Integer; -- (bltn_operators'POS)

++  pragma_id =>	    lx_srcpos -- ALL_SOURCE
++			    lx_symrep -- DEF_NAME
@@  pragma_id =>	    sm_argument_id_s : argument_id;
@@  pragma_id =>            xd_pos: Integer; -- Defined_Pragmas'POS

@@  argument_id_s =>	    as_list : Seq Of argument_id;
++  argument_id_s =>	    lx_srcpos -- ALL_SOURCE

@@  ALL_SOURCE ::=	    DEF_NAME | ALL_DECL | TYPE_DEF | SEQUENCES
@@			  | STM_ELEM | GENERAL_ASSOC | CONSTRAINT | CHOICE
@@			  | HEADER | UNIT_DESC | TEST_CLAUSE_ELEM
@@			  | MEMBERSHIP_OP | SHORT_CIRCUIT_OP | ITERATION
@@			  | ALTERNATIVE_ELEM | COMP_REP_ELEM | CONTEXT_ELEM
@@			  | VARIANT_ELEM | ALIGNMENT_CLAUSE | VARIANT_PART
@@			  | comp_list | compilation | compilation_unit | index;

@@  SEQUENCES ::=	    alternative_s | argument_id_s | choice_s
@@			  | comp_rep_s | compltn_unit_s | context_elem_s
@@			  | decl_s | dscrmt_decl_s | general_assoc_s
@@			  | discrete_range_s | enum_literal_s | exp_s | item_s
@@			  | index_s | name_s | param_s | pragma_s | scalar_s
@@			  | source_name_s | stm_s | test_clause_elem_s
@@			  | use_pragma_s | variant_s;

@@  ALL_SOURCE =>	    lx_srcpos : Source_Position,
@@			    lx_comments : comments;

@@  ALL_DECL ::=	    ITEM | subunit;


@@  user_root =>    xd_sourcename   : txtrep,
@@		    xd_grammar	    : void,
@@		    xd_statelist    : void,
@@		    xd_structure    : compilation,
@@		    xd_timestamp    : Integer,
@@		    spare_3	    : void;
@@
@@  NON_DIANA ::= user_root;

@@  NON_DIANA ::=   real_val | trans_with | lib_info;

@@  --universal real values
@@  real_val	     => xd_numer	: num_val,
@@			xd_denom	: num_val;

@@  trans_with	     => tw_filename	: txtrep,
@@			tw_comp_unit	: compilation_unit;

@@  lib_info	     => xd_short	: txtrep,
@@			xd_primary	: txtrep,
@@			xd_secondary	: txtrep;

@@  any_integer      =>;

@@  any_real	     =>;

@@  any_access	     =>;

@@  any_composite    =>;

@@  any_string	     =>;

@@  any_access_of    => xd_item 	: ITEM;

@@  UNSPECIFIED_TYPE ::= any_access | any_composite | any_string
@@			 | any_access_of | any_integer | any_real ;

@@  NON_DIANA ::= def | UNSPECIFIED_TYPE;

@@  def 	     => xd_header	: HEADER,
@@			xd_source_name	: SOURCE_NAME,
@@			xd_region_def	: def,
@@			xd_is_in_spec	: Boolean,
@@			xd_lex_level	: Integer, -- 0 for non-enclosing
@@			xd_is_used	: Boolean;
@@				-- last two used for regions only

@@ implicit_conv     => xd_item 	: def,	-- (or type spec)
@@			xd_list 	: Seq Of EXP;

@@ nullary_call      => xd_item 	: def;

@@ NON_DIANA ::= implicit_conv | nullary_call;

@@-- Structure Diana_Concrete
@@-- Refines Diana Is
--
--
--
--Refined Diana Specification
--======= ===== =============
--
--
--Version of 11 February 1983
--
--


@@--  For source_position Use USERPK.SOURCE_POSITION;
@@--   -- defines source position in original
@@--   -- source program. used for error messages.
@@--  For symbol_rep Use USERPK.SYMBOL_REP;
@@--   -- representation of identifiers,
@@--			  -- strings and characters
@@--  For value Use USERPK.MACHINE_VALUE;
@@--   -- implementation defined
@@--   -- gives value of an expression.
@@--   -- can indicate that no value is computed.
@@--  For operator Use USERPK.OPERATOR;
@@--   -- enumeration type for all operators
@@--  For number_rep Use USERPK.NUMBER_REP;
@@--   -- representation of numeric literals
@@--  For comments Use USERPK.COMMENTS;
@@--   -- representation of comments from source program
@@--

--
--	  This defines the external representations
--
@@--  For symbol_rep Use External String;
@@--   -- the external representation of
@@--   -- symbol_rep uses IDL basic type string.
@@--  For number_rep Use External String;
@@--   -- the external representation of
@@--   -- number_rep uses IDL basic type string.
@@--  For operator Use	External OP_CLASS;
@@--   -- the external representation of operator
@@--   -- uses the private type OP_CLASS
@@--  For value Use  External VAL_CLASS;
@@--   -- the external representation of values
@@--   -- uses the private type VAL_CLASS



--
-- OP_CLASS is an enumeration class that defines the Ada operators
--
-- Syntax 4.5
--  logical_operator ::= and | or | xor
--
--  relational_operator ::=  = | /= | < | <= | > | >=
--
--  adding_operator ::= + | - | &
--
--  unary_operator ::= + | -
--
--  multiplying_operator ::= * | / | mod | rem
--
--  highest_precedence_operator ::= ** | abs | not
--

--@@  NON_DIANA ::=   OP_CLASS;
--@@  ** operators stored as integer ('POS in enumeration type)

--@@  OP_CLASS ::= and -- and
--@@   | or -- or
--@@   | xor -- xor
--@@   | eq -- =
--@@   | ne -- /=
--@@   | lt -- <
--@@   | le -- <=
--@@   | gt -- >
--@@   | ge -- >=
--@@   | plus -- +
--@@   | minus -- -
--@@   | cat -- &
--@@   | unary_plus -- +
--@@   | unary_minus -- -
--@@   | abs -- abs
--@@   | not -- not
--@@   | mult -- *
--@@   | div -- /
--@@   | mod -- mod
--@@   | rem -- rem
--@@   | exp; -- **
--@@
--@@   and => ;        or => ;		  xor => ;	   eq => ;
--@@   ne => ;	       lt => ;		  le => ;	   gt => ;
--@@   ge => ;	       plus => ;	  minus => ;	   cat => ;
--@@   unary_plus => ;	 unary_minus => ;   abs => ;	   not => ;
--@@   mult => ;       div => ; 	  mod => ;	   rem => ;
--@@   exp => ;


--
-- VAL_CLASS is a class that defines the possible Diana values
--

@@--  VAL_CLASS ::= no_value | string_value | bool_value |
@@--   int_value | real_value;
@@--
@@--  no_value	     => ; -- no value has been computed
@@--  string_value   => str_val 	: String; -- character and string
@@--  bool_value     => boo_val 	: Boolean; -- boolean value
@@--  int_value      => int_val 	: Integer; -- integer value
@@--  real_value     => rtn_val 	: Rational; -- real and fixed values
@@
@@--**	We use void, def_char, false, true, num_val, real_val
@@--**	Note that static value can never be a string

@@End

--** Definitions of rules for meta-brackets
--** Only rules with "standard" definitions are given here:
--**   [xxx]  is void or has semantics of xxx
--**   {xxx}  is a sequence of 0 or more xxx's
--**   other rules combined with {xxx} extend the sequence

{pragma} ::=
       empty					====> nil
     | pragma  {pragma} 			====> insert

{variant_pragma} ::=
       empty					====> nil
     | variant_pragma {variant_pragma}		====> insert

{stm_pragma} ::=
       empty					====> nil
     | stm_pragma  {stm_pragma} 		====> insert

{alternative_pragma} ::=
       empty					====> nil
     | alternative_pragma {alternative_pragma}	====> insert

--{context_pragma} ::=
--	 empty					====> nil
--     | context_pragma {context_pragma}		====> insert

{comp_rep_pragma} ::=
       empty					====> nil
     | comp_rep_pragma {comp_rep_pragma}	====> insert

argument_association{,argument_association} ::=
       argument_association			====> list
    |  argument_association{,argument_association}  ,  argument_association
						====> append

[:=expression] ::=
       empty					====> void
    |  :=  expression

[expression] ::=
       empty					====> void
    |  expression

enumeration_literal{,enumeration_literal} ::=
    enumeration_literal 			====> list
  | enumeration_literal{,enumeration_literal} , enumeration_literal
						====> append

[constraint] ::= empty				====> void
    | constraint

[range_constraint] ::=
       empty					====> void
    |  range_constraint

index_subtype_definition{,index_subtype_definition} ::=
    index_subtype_definition			====> list
  | index_subtype_definition{,index_subtype_definition}
		     ,	index_subtype_definition
						====> append

{pragma}{component_declaration{pragma}} ::=
	{pragma}
     |	{pragma}{component_declaration{pragma}}  component_declaration	{pragma}
						====> insert cat

discriminant_specification{;discriminant_specification} ::=
    discriminant_specification			====> list
  | discriminant_specification{;discriminant_specification}
		;  discriminant_specification	====> append

{variant} ::=
    empty					====> nil
  | {variant}  variant				====> append

choice{|choice} ::=
	choice					====> list
     |  choice{|choice}  '|'  choice            ====> append

{basic_declarative_item{pragma}} ::=
    empty					====> nil
  | {basic_declarative_item{pragma}}
	      basic_declarative_item  {pragma}	====> insert cat

{later_declarative_item{pragma}} ::=
    empty					====> nil
  | {later_declarative_item{pragma}}
	      later_declarative_item  {pragma}	====> insert cat

component_association,{component_association,} ::=
    component_association  ,			====> list
  | component_association,{component_association,}  component_association  ,
						====> append
label{label} ::=
    label					====> list
  | label{label}  label 			====> append

if_clause{elsif_clause} ::=
    if_clause					====> list
  | if_clause{elsif_clause}  elsif_clause	====> append

{case_sta_alt} ::=
    empty					====> nil
  | {case_sta_alt} case_sta_alt 		====> append

[iteration_scheme] ::=
     empty					====> void
   | iteration_scheme

parameter_specification{;parameter_specification} ::=
    parameter_specification			====> list
  | parameter_specification{;parameter_specification}
		;  parameter_specification	====> append

general_assoc{,general_assoc} ::=
    general_assoc				====> list
  | general_assoc{,general_assoc} , general_assoc
						====> append
expanded_name{,expanded_name} ::=
    expanded_name				====> list
  | expanded_name{,expanded_name} , expanded_name
						====> append

{representation_clause{pragma}} ::=
    empty					====> nil
  | representation_clause {pragma} {representation_clause{pragma}}
						====> cat insert

{compilation_unit} ::=
    empty					====> nil
  | {compilation_unit} compilation_unit 	====> append

name{,name} ::=
    name					====> list
  | name{,name} , name				====> append

{with_clause} ::=
	empty					====> nil
      | {with_clause}  with_clause		====> append

{use_clause{pragma}} ::=
	empty					====> nil
      | {use_clause{pragma}} use_clause {pragma}
						====> insert cat

[expanded_name] ::=
	empty					====> void
     |	expanded_name

{entry_declaration{pragma}} ::=
    empty					====> nil
  | {entry_declaration{pragma}} entry_declaration {pragma}
						====> insert cat

{generic_parameter_declaration{pragma}} ::=
    empty					====> nil
  | {generic_parameter_declaration{pragma}} generic_parameter_declaration
		{pragma}			====> insert cat

generic_association{,generic_association} ::=
    generic_association 			====> list
  | generic_association{,generic_association} , generic_association
						====> append

{component_clause{comp_rep_pragma}} ::=
    empty					====> nil
  | {component_clause{comp_rep_pragma}} component_clause {comp_rep_pragma}
						====> insert cat

discrete_range{,discrete_range} ::=
    discrete_range				====> list
  | discrete_range{,discrete_range}  ,	discrete_range
						====> append

discriminant_association{,discriminant_association} ::=
    discriminant_association			====> list
  | discriminant_association{,discriminant_association}
		  ,  discriminant_association
						====> append

discriminant_choice{|discriminant_choice} ::=
    discriminant_choice 			====> list
  | discriminant_choice{|discriminant_choice}  '|'  discriminant_choice
						====> append

%end -------------------------------------------------------------------
